import {
  Canvas,
  addEffect,
  createPortal,
  invalidate,
  useFrame,
  useLoader,
  useThree
} from "./chunk-XU5R6TQV.js";
import {
  create
} from "./chunk-UYWRPOP3.js";
import {
  CanvasTexture,
  Color,
  DefaultLoadingManager,
  ImageBitmapLoader,
  MathUtils,
  Scene,
  Texture,
  TextureLoader,
  Vector2
} from "./chunk-RI5FDDU7.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i2 = 1; i2 < tokens.length; i2++) {
          input = decodeComponents(tokens, i2).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i2 = 0; i2 < entries.length; i2++) {
        var key = entries[i2];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "node_modules/filter-obj/index.js"(exports, module) {
    "use strict";
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode(key, options), "=", encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b) => Number(a2) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse(query2, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query2 !== "string") {
        return ret;
      }
      query2 = query2.trim().replace(/^[?#&]/, "");
      if (!query2) {
        return ret;
      }
      for (const param of query2.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query2 = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query2, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${encode(object.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true
      }, options);
      const { url, query: query2, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query2, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports, module) {
    function debounce2(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (null == wait) wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce2.debounce = debounce2;
    module.exports = debounce2;
  }
});

// node_modules/vecn/src/index.js
var require_src = __commonJS({
  "node_modules/vecn/src/index.js"(exports, module) {
    var vecTypes = function() {
      const handler = {
        get: function(obj, prop) {
          if (!obj.hasOwnProperty(prop)) {
            obj[prop] = getVecType(prop);
          }
          return obj[prop];
        }
      };
      return new Proxy({}, handler);
    }();
    var vecn = class extends Array {
      /**
       * Creates a vecn of the specified dimension. This should never be called
       * by the user (as if this were an abstract class).
       * @param {number} dimension The dimension of this vector.
       * @param {number[]} [args=[]] The numbers to be put in the vector.
       */
      constructor(dimension, args) {
        args = flattenOuter(args);
        if (!args.every((x) => type(x) === "Number")) {
          throw new TypeError("All arguments must be numbers.");
        }
        if (args.length > 1 && args.length !== dimension) {
          throw new Error("Argument list must be empty, have a single number, or have a length equal to the dimension.");
        }
        if (args.length === 0) {
          args = [0];
        }
        if (args.length === 1 && type(args[0]) === "Number") {
          args = Array(dimension).fill(args[0]);
        }
        if (dimension > 1) {
          super(...args);
        } else {
          super(1);
          this[0] = args[0];
        }
        Reflect.defineProperty(this, "pop", {
          value: void 0,
          enumerable: false
        });
        Reflect.defineProperty(this, "push", {
          value: void 0,
          enumerable: false
        });
        Reflect.defineProperty(this, "shift", {
          value: void 0,
          enumerable: false
        });
        Reflect.defineProperty(this, "unshift", {
          value: void 0,
          enumerable: false
        });
      }
      /**
       * The L2 norm (Euclidian norm) of the vector.
       * @type {number}
       */
      get magnitude() {
        return this.pnorm(2);
      }
      // --------------------------------------------------------------------------
      //   Arithmetic
      /**
       * Returns a vector where this is divided by v componentwise. If v is
       * a single number, the vector is scaled by 1/v.
       * @param {number|number[]} v The value to multiply with.
       *
       * @returns {vecn} A new vector with the divided components.
       */
      div(v) {
        checkCompatibility(v, this.dim, true);
        if (type(v) === "Number") {
          v = new Array(this.dim).fill(v);
        }
        let result = [];
        for (let i2 = 0; i2 < this.length; ++i2) {
          result[i2] = this[i2] / v[i2];
        }
        return vecTypes[this.dim](result);
      }
      /**
       * Returns a vector where v is subtracted from the components of this
       * vector. If v is a single number, it is subtracted to each component. If v
       * is a vector, the vectors are combined componentwise.
       * @param {number|number[]} v The value to subtract from this vector.
       *
       * @returns {vecn} A new vector with the combined components.
       */
      minus(v) {
        checkCompatibility(v, this.dim, true);
        if (type(v) === "Number") {
          v = new Array(this.dim).fill(v);
        }
        let result = [];
        for (let i2 = 0; i2 < this.dim; ++i2) {
          result[i2] = this[i2] - v[i2];
        }
        return vecTypes[this.dim](result);
      }
      /**
       * Negates each element in this vector.
       * @returns {vecn} A new vector where all elements are negated.
       */
      neg() {
        return vecTypes[this.dim](this.times(-1));
      }
      /**
       * Returns a vector where v is added to the components of this vector. If v
       * is a single number, it is added to each component. If v is a vector, the
       * vectors are added componentwise.
       * @param {number|number[]} v The value to add to this vector.
       *
       * @returns {vecn} A new vector with the summed components.
       */
      plus(v) {
        checkCompatibility(v, this.dim, true);
        if (type(v) === "Number") {
          v = new Array(this.dim).fill(v);
        }
        let result = [];
        for (let i2 = 0; i2 < this.dim; ++i2) {
          result[i2] = this[i2] + v[i2];
        }
        return vecTypes[this.dim](result);
      }
      /**
       * Returns a vector where each component of this was raised to a power p.
       * @param {number} p The power to raise each component by.
       *
       * @returns {vecn} A new vector with the exponentiated components.
       */
      pow(p2) {
        let result = [];
        for (let i2 = 0; i2 < this.dim; ++i2) {
          result[i2] = Math.pow(this[i2], p2);
        }
        return vecTypes[this.dim](result);
      }
      /**
       * Returns a vector where v and this are multiplied componentwise. If v is
       * a single number, the vector is scaled by v.
       * @param {number|number[]} v The value to multiply with.
       *
       * @returns {vecn} A new vector with the multiplied components.
       */
      times(v) {
        checkCompatibility(v, this.dim, true);
        if (type(v) === "Number") {
          v = new Array(this.dim).fill(v);
        }
        let result = [];
        for (let i2 = 0; i2 < this.dim; ++i2) {
          result[i2] = this[i2] * v[i2];
        }
        return vecTypes[this.dim](result);
      }
      // --------------------------------------------------------------------------
      //   Vector Operations
      /**
       * Dot product of two vectors.
       * @param {number[]} v The vector to dot with this one.
       *
       * @returns {number} The dot product between this and v.
       */
      dot(v) {
        checkCompatibility(v, this.dim);
        let result = 0;
        for (let i2 = 0; i2 < this.dim; ++i2) {
          result += this[i2] * v[i2];
        }
        return result;
      }
      /**
       * Scales this vector to a magnitude of 1.
       *
       * @returns {vecn} A new vector with scaled components.
       */
      normalize() {
        return this.div(this.magnitude);
      }
      /**
       * Evaluates the p-norm (or lp-norm) of this vector.
       * @param {number} p The p-value to evaluate.
       *
       * @returns {number} The norm of this vector.
       */
      pnorm(p2) {
        let result = 0;
        for (let i2 = 0; i2 < this.dim; ++i2) {
          result += Math.pow(Math.abs(this[i2]), p2);
        }
        return Math.pow(result, 1 / p2);
      }
      /**
       * Reflects this vector across the provided vector. The normal can be imagined
       * as a surface normal or as describing a hyperpalane.
       * @param {number[]} normal A vector describing the hyperplane to reflect off of.
       *
       * @returns {vecn} The reflected vector.
       */
      reflect(normal) {
        const n2 = normal.normalize();
        return this.minus(n2.times(2 * this.dot(n2)));
      }
      // --------------------------------------------------------------------------
      //   Extras
      /**
       * Finds the indices of the max value in this vector.
       *
       * @returns {number[]} An array of indices corresponding to the max values.
       */
      argmax() {
        const maxVal = this.max();
        return this.reduce((acc, x, i2) => x === maxVal ? acc.concat([i2]) : acc, []);
      }
      /**
       * Finds the indices of the min value in this vector.
       *
       * @returns {number[]} An array of indices corresponding to the min values.
       */
      argmin() {
        const minVal = this.min();
        return this.reduce((acc, x, i2) => x === minVal ? acc.concat([i2]) : acc, []);
      }
      /**
       * Creates a new vector from the provided indices of this one. Basically
       * equivalent to swizzling.
       * @param {number[]} indices The indices to select into a new vector.
       *
       * @returns {vecn} A new vector from the provided indices.
       */
      choose(indices) {
        if (!Array.isArray(indices)) {
          throw new TypeError("Argument must be a list of indices.");
        }
        if (!indices.every((i2) => i2 < this.dim && isIndex(i2.toString()))) {
          throw new RangeError("All elements of argument must be valid indices.");
        }
        let v = [];
        indices.forEach((i2) => v.push(this[i2]));
        return vecTypes[v.length](v);
      }
      /**
       * Creates a duplicate of this vector. Same as passing this vector through
       * the factory that created it.
       *
       * @returns {vecn} A deep copy of this vector.
       */
      copy() {
        return vecTypes[this.dim](this);
      }
      /**
       * Returns whether every element in each vector is equal.
       * @param {number[]} v A vector to test against.
       *
       * @returns {boolean} True if both vectors have the same dimension and values.
       */
      equals(v) {
        return v.length === this.dim && v.every((x, i2) => this[i2] === x);
      }
      /**
       * Returns whether every element in each vector is approximately equal.
       * @param {number[]} v A vector to test against.
       * @param {number} epsilon The largest meaningful difference between two values.
       *
       * @returns {boolean} True if both vectors have the same dimension and the
       * distance between each number is less than epsilon.
       */
      approximatelyEquals(v, epsilon = 1e-8) {
        return v.length === this.dim && v.every((x, i2) => Math.abs(this[i2] - x) < epsilon);
      }
      /**
       * Returns the max value of this vector.
       *
       * @returns {number} The max value of this vector.
       */
      max() {
        return Math.max(...this);
      }
      /**
       * Returns the min value of this vector.
       *
       * @returns {number} The min value of this vector.
       */
      min() {
        return Math.min(...this);
      }
      /**
       * Sums the components of this vector.
       *
       * @returns {number} The sum of the components of this vector.
       */
      sum() {
        return this.reduce((acc, x) => acc + x, 0);
      }
      /**
       * Converts this vector into an Array.
       *
       * @returns {number[]} An array of the contents of this vector.
       */
      toArray() {
        return Array.from(this);
      }
      // --------------------------------------------------------------------------
      //   Array Overrides
      /**
       * Same as Array.prototype.concat, but return value is of a new vecType.
       *
       * @returns {vecn}
       */
      concat(...args) {
        const result = super.concat.apply(this.toArray(), args);
        return vecTypes[result.length](result);
      }
      /**
       * Same as Array.prototype.filter, but returns an Array if the result has 0
       * entries.
       *
       * @returns {vecn|number[]}
       */
      filter(...args) {
        const result = super.filter.apply(this.toArray(), args);
        if (result.length > 0) {
          return vecTypes[result.length](result);
        }
        return result;
      }
      /**
       * Same as Array.prototype.map, but returns an Array if the result contains
       * non-numbers.
       *
       * @returns {vecn|Array}
       */
      map(...args) {
        const result = super.map(...args);
        if (result.every((x) => type(x) === "Number")) {
          return result;
        }
        return result.toArray();
      }
      /**
       * Same as Array.prototype.slice, but returns an Array if the result has 0
       * entries.
       */
      slice(...args) {
        const result = super.slice.apply(this.toArray(), args);
        if (result.length > 0) {
          return vecTypes[result.length](result);
        }
        return result;
      }
      /**
       * A restrictive version of the Array.prototype.splice that requires all
       * removed elements to be replaced.
       */
      splice(...args) {
        let test = this.toArray();
        test.splice(...args);
        if (test.length !== this.dim) {
          throw new Error("All removed elements must be replaced.");
        }
        if (!test.every((x) => type(x) === "Number")) {
          throw new TypeError("All elements must be numbers.");
        }
        test.forEach((x, i2) => {
          this[i2] = x;
        });
      }
      toString() {
        return this.reduce((s2, x, i2) => {
          return s2 + x + (i2 === this.dim - 1 ? " " : ", ");
        }, "[ ") + "]";
      }
    };
    function add(...vecs) {
      const dim = vecs[0].dim;
      if (!vecs.every((v) => v.dim === dim)) {
        throw new TypeError("All vectors must have the same dimension.");
      }
      return vecs.reduce((acc, v) => acc.plus(v), vecTypes[dim]());
    }
    var validator = {
      set: function(obj, prop, value) {
        if (prop === "length") {
          return false;
        }
        if (isIndex(prop)) {
          if (Number(prop) >= obj.dim) {
            throw new RangeError("Vector may not have more elements than dimension.");
          } else if (type(value) !== "Number") {
            throw new TypeError("Vectors may only contain numbers.");
          } else {
            obj[prop] = value;
            return true;
          }
        }
        const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString());
        if (obj.dim <= 4 && swizzleSymbolMap) {
          swizzleSet(obj, prop.toString(), swizzleSymbolMap, value);
          return true;
        }
        return false;
      },
      get: function(obj, prop) {
        const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString());
        if (obj.dim <= 4 && swizzleSymbolMap) {
          return swizzleGet(obj, prop, swizzleSymbolMap);
        }
        return obj[prop];
      }
    };
    function getVecType(dim) {
      dim = Number(dim);
      if (!(dim in vecTypes)) {
        if (isNaN(dim)) throw new TypeError("Dimension must be coercible to a number.");
        if (dim <= 0) throw new RangeError("Dimension must be positive.");
        if (!Number.isInteger(dim)) throw new RangeError("Dimension must be positive.");
        let classname = "vec" + dim;
        let VecType = { [classname]: class extends vecn {
          constructor(...args) {
            if (args.length === 1 && args[0] instanceof vecn) {
              if (args[0].dim > dim) {
                throw new TypeError("Cannot demote vectors.");
              }
              args = promoteArrayDimension(args[0].toArray(), dim);
            }
            super(dim, args);
            Reflect.defineProperty(this, "dim", {
              value: dim,
              writable: false,
              enumerable: false
            });
          }
        } }[classname];
        let factory = function factory2(...args) {
          let target = new VecType(...args);
          Object.preventExtensions(target);
          return new Proxy(target, validator);
        };
        vecTypes[dim] = factory;
      }
      return vecTypes[dim];
    }
    function isVec(v) {
      return v instanceof vecn;
    }
    function lerp2(v1, v2, t2) {
      if (v1.dim !== v2.dim) throw new TypeError("Vectors must have the same dimension.");
      t2 = t2 < 0 ? 0 : t2 > 1 ? 1 : t2;
      return v1.plus(v2.minus(v1).times(t2));
    }
    function multiply(...vecs) {
      const dim = vecs[0].dim;
      if (!vecs.every((v) => v.dim === dim)) throw new TypeError("All vectors must have the same dimension.");
      return vecs.reduce((acc, v) => acc.times(v), vecTypes[dim](1));
    }
    function slerp(v1, v2, t2) {
      if (v1.dim !== v2.dim) throw new TypeError("Vectors must have the same dimension.");
      t2 = t2 < 0 ? 0 : t2 > 1 ? 1 : t2;
      let dot = v1.normalize().dot(v2.normalize());
      dot = dot < -1 ? -1 : dot > 1 ? 1 : dot;
      const theta = Math.acos(dot) * t2;
      const relative = v2.minus(v1.times(dot)).normalize();
      const magnitude = v1.magnitude + (v2.magnitude - v1.magnitude) * t2;
      return v1.times(Math.cos(theta)).plus(relative.times(Math.sin(theta))).normalize().times(magnitude);
    }
    var namedIndices = [
      { x: 0, y: 1, z: 2, w: 3 },
      { r: 0, g: 1, b: 2, a: 3 },
      { s: 0, t: 1, p: 2, q: 3 }
    ];
    function getSwizzleSymbolMap(s2) {
      return namedIndices.find((map) => {
        return s2.split("").every((c2) => c2 in map);
      });
    }
    function swizzleGet(v, s2, set) {
      const newDim = s2.length;
      if (newDim === 1) {
        return v[set[s2]];
      }
      let values = s2.split("").reduce((acc, x) => {
        let i2 = set[x];
        return acc && i2 < v.dim ? acc.concat([v[i2]]) : void 0;
      }, []);
      return values ? new vecTypes[newDim](...values) : void 0;
    }
    function swizzleSet(v, s2, map, newVals) {
      if (s2.length === 1) {
        if (type(newVals) !== "Number") {
          throw new TypeError("Must set to a number");
        }
        v[map[s2]] = newVals;
        return;
      }
      if (!Array.isArray(newVals)) throw new TypeError("Right-hand side must be an array.");
      if (s2.length !== newVals.length) throw new TypeError("Right-hand side must have matching length.");
      if (!newVals.every((item) => type(item) === "Number")) throw new TypeError("All new values must be numbers.");
      if (s2.split("").some((c2) => map[c2] >= v.dim)) {
        return;
      }
      let valid = true;
      for (let i2 = 0, unique = {}; i2 < s2.length; ++i2) {
        if (unique.hasOwnProperty(s2[i2])) {
          valid = false;
          break;
        }
        unique[s2[i2]] = true;
      }
      if (!valid) throw new SyntaxError("Swizzle assignment does not allow symbols to be repeated.");
      s2.split("").map((c2) => map[c2]).forEach((index, i2) => {
        v[index] = newVals[i2];
      });
    }
    function checkCompatibility(o2, dim, numberValid = false) {
      if (numberValid && type(o2) === "Number") {
        return;
      } else if (o2.length && o2.length === dim) {
        return;
      }
      throw new TypeError(`Invalid argument. Input must have matching dimension${numberValid ? "or be a scalar" : ""}.`);
    }
    function flattenOuter(arr) {
      if (!(arr instanceof Array) || arr.length !== 1) {
        return arr;
      }
      if (arr[0] instanceof Array) {
        return flattenOuter(arr[0]);
      }
      return arr;
    }
    function isIndex(n2) {
      return !isNaN(n2) && Number(n2).toString() === n2 && Number.isInteger(Number(n2)) && Number(n2) >= 0;
    }
    function promoteArrayDimension(arr, dim) {
      return [...Array(dim)].map((_, i2) => i2 < arr.length ? arr[i2] : 0);
    }
    function type(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1);
    }
    module.exports = {
      getVecType,
      isVec,
      vec2: vecTypes[2],
      vec3: vecTypes[3],
      vec4: vecTypes[4],
      add,
      multiply,
      lerp: lerp2,
      slerp
    };
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length, i2, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal(a2[key], b[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    };
  }
});

// node_modules/@14islands/r3f-scroll-rig/dist/scrollrig.modern.js
var import_react = __toESM(require_react());

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
    return { x, y, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global = typeof window !== "undefined" ? window : {};

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver3() {
    requestAnimationFrame(cb);
  });
};

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n2) {
  !watching && n2 > 0 && scheduler.start();
  watching += n2;
  !watching && scheduler.stop();
};

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i2 = 0; i2 < observationTargets.length; i2 += 1) {
    if (observationTargets[i2].target === target) {
      return i2;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver2 = function() {
  function ResizeObserver3(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver3.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver3.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver3.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver3.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver3;
}();

// node_modules/@14islands/r3f-scroll-rig/dist/scrollrig.modern.js
var import_query_string = __toESM(require_query_string());

// node_modules/react-intersection-observer/dist/index.mjs
var React = __toESM(require_react(), 1);
var React2 = __toESM(require_react(), 1);
var observerMap2 = /* @__PURE__ */ new Map();
var RootIds = /* @__PURE__ */ new WeakMap();
var rootId = 0;
var unsupportedValue = void 0;
function getRootId(root) {
  if (!root) return "0";
  if (RootIds.has(root)) return RootIds.get(root);
  rootId += 1;
  RootIds.set(root, rootId.toString());
  return RootIds.get(root);
}
function optionsToId(options) {
  return Object.keys(options).sort().filter(
    (key) => options[key] !== void 0
  ).map((key) => {
    return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
  }).toString();
}
function createObserver(options) {
  const id = optionsToId(options);
  let instance = observerMap2.get(id);
  if (!instance) {
    const elements = /* @__PURE__ */ new Map();
    let thresholds;
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        var _a;
        const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
        if (options.trackVisibility && typeof entry.isVisible === "undefined") {
          entry.isVisible = inView;
        }
        (_a = elements.get(entry.target)) == null ? void 0 : _a.forEach((callback) => {
          callback(inView, entry);
        });
      });
    }, options);
    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance = {
      id,
      observer,
      elements
    };
    observerMap2.set(id, instance);
  }
  return instance;
}
function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
  if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
    const bounds = element.getBoundingClientRect();
    callback(fallbackInView, {
      isIntersecting: fallbackInView,
      target: element,
      intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
      time: 0,
      boundingClientRect: bounds,
      intersectionRect: bounds,
      rootBounds: bounds
    });
    return () => {
    };
  }
  const { id, observer, elements } = createObserver(options);
  const callbacks2 = elements.get(element) || [];
  if (!elements.has(element)) {
    elements.set(element, callbacks2);
  }
  callbacks2.push(callback);
  observer.observe(element);
  return function unobserve() {
    callbacks2.splice(callbacks2.indexOf(callback), 1);
    if (callbacks2.length === 0) {
      elements.delete(element);
      observer.unobserve(element);
    }
    if (elements.size === 0) {
      observer.disconnect();
      observerMap2.delete(id);
    }
  };
}
function useInView({
  threshold,
  delay,
  trackVisibility,
  rootMargin,
  root,
  triggerOnce,
  skip,
  initialInView,
  fallbackInView,
  onChange
} = {}) {
  var _a;
  const [ref, setRef] = React2.useState(null);
  const callback = React2.useRef(onChange);
  const [state, setState] = React2.useState({
    inView: !!initialInView,
    entry: void 0
  });
  callback.current = onChange;
  React2.useEffect(
    () => {
      if (skip || !ref) return;
      let unobserve;
      unobserve = observe(
        ref,
        (inView, entry) => {
          setState({
            inView,
            entry
          });
          if (callback.current) callback.current(inView, entry);
          if (entry.isIntersecting && triggerOnce && unobserve) {
            unobserve();
            unobserve = void 0;
          }
        },
        {
          root,
          rootMargin,
          threshold,
          // @ts-ignore
          trackVisibility,
          // @ts-ignore
          delay
        },
        fallbackInView
      );
      return () => {
        if (unobserve) {
          unobserve();
        }
      };
    },
    // We break the rule here, because we aren't including the actual `threshold` variable
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      // If the threshold is an array, convert it to a string, so it won't change between renders.
      Array.isArray(threshold) ? threshold.toString() : threshold,
      ref,
      root,
      rootMargin,
      triggerOnce,
      skip,
      trackVisibility,
      fallbackInView,
      delay
    ]
  );
  const entryTarget = (_a = state.entry) == null ? void 0 : _a.target;
  const previousEntryTarget = React2.useRef(void 0);
  if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {
    previousEntryTarget.current = entryTarget;
    setState({
      inView: !!initialInView,
      entry: void 0
    });
  }
  const result = [setRef, state.inView, state.entry];
  result.ref = result[0];
  result.inView = result[1];
  result.entry = result[2];
  return result;
}

// node_modules/@14islands/r3f-scroll-rig/dist/scrollrig.modern.js
var import_debounce = __toESM(require_debounce());
var import_vecn = __toESM(require_src());

// node_modules/@14islands/r3f-scroll-rig/node_modules/suspend-react/dist/index.js
function shallowEqualArrays(arrA, arrB, equal = (a2, b) => a2 === b) {
  if (arrA === arrB) return true;
  if (!arrA || !arrB) return false;
  const len = arrA.length;
  if (arrB.length !== len) return false;
  for (let i2 = 0; i2 < len; i2++) if (!equal(arrA[i2], arrB[i2])) return false;
  return true;
}
var globalCache = [];
function query(fn, keys, preload = false, config = {}) {
  for (const entry2 of globalCache) {
    if (shallowEqualArrays(keys, entry2.keys, entry2.equal)) {
      if (preload) return void 0;
      if (Object.prototype.hasOwnProperty.call(entry2, "error")) throw entry2.error;
      if (Object.prototype.hasOwnProperty.call(entry2, "response")) return entry2.response;
      if (!preload) throw entry2.promise;
    }
  }
  const entry = {
    keys,
    equal: config.equal,
    promise: (
      // Execute the promise
      fn(...keys).then((response) => entry.response = response).then(() => {
        if (config.lifespan && config.lifespan > 0) {
          setTimeout(() => {
            const index = globalCache.indexOf(entry);
            if (index !== -1) globalCache.splice(index, 1);
          }, config.lifespan);
        }
      }).catch((error) => entry.error = error)
    )
  };
  globalCache.push(entry);
  if (!preload) throw entry.promise;
  return void 0;
}
var suspend = (fn, keys, config) => query(fn, keys, false, config);

// node_modules/supports-webp/index.js
var supports_webp_default = new Promise((resolve) => {
  const image = new Image();
  image.addEventListener("error", () => resolve(false));
  image.addEventListener("load", () => resolve(image.width === 1));
  image.src = "data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA=";
}).catch(() => false);

// node_modules/@14islands/r3f-scroll-rig/dist/scrollrig.modern.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());

// node_modules/lenis/dist/lenis.mjs
var version = "1.3.11";
function clamp(min, input, max) {
  return Math.max(min, Math.min(input, max));
}
function lerp(x, y, t2) {
  return (1 - t2) * x + t2 * y;
}
function damp(x, y, lambda, deltaTime) {
  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));
}
function modulo(n2, d2) {
  return (n2 % d2 + d2) % d2;
}
var Animate = class {
  isRunning = false;
  value = 0;
  from = 0;
  to = 0;
  currentTime = 0;
  // These are instanciated in the fromTo method
  lerp;
  duration;
  easing;
  onUpdate;
  /**
   * Advance the animation by the given delta time
   *
   * @param deltaTime - The time in seconds to advance the animation
   */
  advance(deltaTime) {
    if (!this.isRunning) return;
    let completed = false;
    if (this.duration && this.easing) {
      this.currentTime += deltaTime;
      const linearProgress = clamp(0, this.currentTime / this.duration, 1);
      completed = linearProgress >= 1;
      const easedProgress = completed ? 1 : this.easing(linearProgress);
      this.value = this.from + (this.to - this.from) * easedProgress;
    } else if (this.lerp) {
      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);
      if (Math.round(this.value) === this.to) {
        this.value = this.to;
        completed = true;
      }
    } else {
      this.value = this.to;
      completed = true;
    }
    if (completed) {
      this.stop();
    }
    this.onUpdate?.(this.value, completed);
  }
  /** Stop the animation */
  stop() {
    this.isRunning = false;
  }
  /**
   * Set up the animation from a starting value to an ending value
   * with optional parameters for lerping, duration, easing, and onUpdate callback
   *
   * @param from - The starting value
   * @param to - The ending value
   * @param options - Options for the animation
   */
  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {
    this.from = this.value = from;
    this.to = to;
    this.lerp = lerp2;
    this.duration = duration;
    this.easing = easing;
    this.currentTime = 0;
    this.isRunning = true;
    onStart?.();
    this.onUpdate = onUpdate;
  }
};
function debounce(callback, delay) {
  let timer;
  return function(...args) {
    let context = this;
    clearTimeout(timer);
    timer = setTimeout(() => {
      timer = void 0;
      callback.apply(context, args);
    }, delay);
  };
}
var Dimensions = class {
  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {
    this.wrapper = wrapper;
    this.content = content;
    if (autoResize) {
      this.debouncedResize = debounce(this.resize, debounceValue);
      if (this.wrapper instanceof Window) {
        window.addEventListener("resize", this.debouncedResize, false);
      } else {
        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);
        this.wrapperResizeObserver.observe(this.wrapper);
      }
      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);
      this.contentResizeObserver.observe(this.content);
    }
    this.resize();
  }
  width = 0;
  height = 0;
  scrollHeight = 0;
  scrollWidth = 0;
  // These are instanciated in the constructor as they need information from the options
  debouncedResize;
  wrapperResizeObserver;
  contentResizeObserver;
  destroy() {
    this.wrapperResizeObserver?.disconnect();
    this.contentResizeObserver?.disconnect();
    if (this.wrapper === window && this.debouncedResize) {
      window.removeEventListener("resize", this.debouncedResize, false);
    }
  }
  resize = () => {
    this.onWrapperResize();
    this.onContentResize();
  };
  onWrapperResize = () => {
    if (this.wrapper instanceof Window) {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
    } else {
      this.width = this.wrapper.clientWidth;
      this.height = this.wrapper.clientHeight;
    }
  };
  onContentResize = () => {
    if (this.wrapper instanceof Window) {
      this.scrollHeight = this.content.scrollHeight;
      this.scrollWidth = this.content.scrollWidth;
    } else {
      this.scrollHeight = this.wrapper.scrollHeight;
      this.scrollWidth = this.wrapper.scrollWidth;
    }
  };
  get limit() {
    return {
      x: this.scrollWidth - this.width,
      y: this.scrollHeight - this.height
    };
  }
};
var Emitter = class {
  events = {};
  /**
   * Emit an event with the given data
   * @param event Event name
   * @param args Data to pass to the event handlers
   */
  emit(event, ...args) {
    let callbacks2 = this.events[event] || [];
    for (let i2 = 0, length = callbacks2.length; i2 < length; i2++) {
      callbacks2[i2]?.(...args);
    }
  }
  /**
   * Add a callback to the event
   * @param event Event name
   * @param cb Callback function
   * @returns Unsubscribe function
   */
  on(event, cb) {
    this.events[event]?.push(cb) || (this.events[event] = [cb]);
    return () => {
      this.events[event] = this.events[event]?.filter((i2) => cb !== i2);
    };
  }
  /**
   * Remove a callback from the event
   * @param event Event name
   * @param callback Callback function
   */
  off(event, callback) {
    this.events[event] = this.events[event]?.filter((i2) => callback !== i2);
  }
  /**
   * Remove all event listeners and clean up
   */
  destroy() {
    this.events = {};
  }
};
var LINE_HEIGHT = 100 / 6;
var listenerOptions = { passive: false };
var VirtualScroll = class {
  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {
    this.element = element;
    this.options = options;
    window.addEventListener("resize", this.onWindowResize, false);
    this.onWindowResize();
    this.element.addEventListener("wheel", this.onWheel, listenerOptions);
    this.element.addEventListener(
      "touchstart",
      this.onTouchStart,
      listenerOptions
    );
    this.element.addEventListener(
      "touchmove",
      this.onTouchMove,
      listenerOptions
    );
    this.element.addEventListener("touchend", this.onTouchEnd, listenerOptions);
  }
  touchStart = {
    x: 0,
    y: 0
  };
  lastDelta = {
    x: 0,
    y: 0
  };
  window = {
    width: 0,
    height: 0
  };
  emitter = new Emitter();
  /**
   * Add an event listener for the given event and callback
   *
   * @param event Event name
   * @param callback Callback function
   */
  on(event, callback) {
    return this.emitter.on(event, callback);
  }
  /** Remove all event listeners and clean up */
  destroy() {
    this.emitter.destroy();
    window.removeEventListener("resize", this.onWindowResize, false);
    this.element.removeEventListener("wheel", this.onWheel, listenerOptions);
    this.element.removeEventListener(
      "touchstart",
      this.onTouchStart,
      listenerOptions
    );
    this.element.removeEventListener(
      "touchmove",
      this.onTouchMove,
      listenerOptions
    );
    this.element.removeEventListener(
      "touchend",
      this.onTouchEnd,
      listenerOptions
    );
  }
  /**
   * Event handler for 'touchstart' event
   *
   * @param event Touch event
   */
  onTouchStart = (event) => {
    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;
    this.touchStart.x = clientX;
    this.touchStart.y = clientY;
    this.lastDelta = {
      x: 0,
      y: 0
    };
    this.emitter.emit("scroll", {
      deltaX: 0,
      deltaY: 0,
      event
    });
  };
  /** Event handler for 'touchmove' event */
  onTouchMove = (event) => {
    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;
    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;
    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;
    this.touchStart.x = clientX;
    this.touchStart.y = clientY;
    this.lastDelta = {
      x: deltaX,
      y: deltaY
    };
    this.emitter.emit("scroll", {
      deltaX,
      deltaY,
      event
    });
  };
  onTouchEnd = (event) => {
    this.emitter.emit("scroll", {
      deltaX: this.lastDelta.x,
      deltaY: this.lastDelta.y,
      event
    });
  };
  /** Event handler for 'wheel' event */
  onWheel = (event) => {
    let { deltaX, deltaY, deltaMode } = event;
    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;
    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;
    deltaX *= multiplierX;
    deltaY *= multiplierY;
    deltaX *= this.options.wheelMultiplier;
    deltaY *= this.options.wheelMultiplier;
    this.emitter.emit("scroll", { deltaX, deltaY, event });
  };
  onWindowResize = () => {
    this.window = {
      width: window.innerWidth,
      height: window.innerHeight
    };
  };
};
var defaultEasing = (t2) => Math.min(1, 1.001 - Math.pow(2, -10 * t2));
var Lenis = class {
  _isScrolling = false;
  // true when scroll is animating
  _isStopped = false;
  // true if user should not be able to scroll - enable/disable programmatically
  _isLocked = false;
  // same as isStopped but enabled/disabled when scroll reaches target
  _preventNextNativeScrollEvent = false;
  _resetVelocityTimeout = null;
  __rafID = null;
  /**
   * Whether or not the user is touching the screen
   */
  isTouching;
  /**
   * The time in ms since the lenis instance was created
   */
  time = 0;
  /**
   * User data that will be forwarded through the scroll event
   *
   * @example
   * lenis.scrollTo(100, {
   *   userData: {
   *     foo: 'bar'
   *   }
   * })
   */
  userData = {};
  /**
   * The last velocity of the scroll
   */
  lastVelocity = 0;
  /**
   * The current velocity of the scroll
   */
  velocity = 0;
  /**
   * The direction of the scroll
   */
  direction = 0;
  /**
   * The options passed to the lenis instance
   */
  options;
  /**
   * The target scroll value
   */
  targetScroll;
  /**
   * The animated scroll value
   */
  animatedScroll;
  // These are instanciated here as they don't need information from the options
  animate = new Animate();
  emitter = new Emitter();
  // These are instanciated in the constructor as they need information from the options
  dimensions;
  // This is not private because it's used in the Snap class
  virtualScroll;
  constructor({
    wrapper = window,
    content = document.documentElement,
    eventsTarget = wrapper,
    smoothWheel = true,
    syncTouch = false,
    syncTouchLerp = 0.075,
    touchInertiaExponent = 1.7,
    duration,
    // in seconds
    easing,
    lerp: lerp2 = 0.1,
    infinite = false,
    orientation = "vertical",
    // vertical, horizontal
    gestureOrientation = orientation === "horizontal" ? "both" : "vertical",
    // vertical, horizontal, both
    touchMultiplier = 1,
    wheelMultiplier = 1,
    autoResize = true,
    prevent,
    virtualScroll,
    overscroll = true,
    autoRaf = false,
    anchors = false,
    autoToggle = false,
    // https://caniuse.com/?search=transition-behavior
    allowNestedScroll = false,
    __experimental__naiveDimensions = false
  } = {}) {
    window.lenisVersion = version;
    if (!wrapper || wrapper === document.documentElement) {
      wrapper = window;
    }
    if (typeof duration === "number" && typeof easing !== "function") {
      easing = defaultEasing;
    } else if (typeof easing === "function" && typeof duration !== "number") {
      duration = 1;
    }
    this.options = {
      wrapper,
      content,
      eventsTarget,
      smoothWheel,
      syncTouch,
      syncTouchLerp,
      touchInertiaExponent,
      duration,
      easing,
      lerp: lerp2,
      infinite,
      gestureOrientation,
      orientation,
      touchMultiplier,
      wheelMultiplier,
      autoResize,
      prevent,
      virtualScroll,
      overscroll,
      autoRaf,
      anchors,
      autoToggle,
      allowNestedScroll,
      __experimental__naiveDimensions
    };
    this.dimensions = new Dimensions(wrapper, content, { autoResize });
    this.updateClassName();
    this.targetScroll = this.animatedScroll = this.actualScroll;
    this.options.wrapper.addEventListener("scroll", this.onNativeScroll, false);
    this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
      capture: true
    });
    if (this.options.anchors && this.options.wrapper === window) {
      this.options.wrapper.addEventListener(
        "click",
        this.onClick,
        false
      );
    }
    this.options.wrapper.addEventListener(
      "pointerdown",
      this.onPointerDown,
      false
    );
    this.virtualScroll = new VirtualScroll(eventsTarget, {
      touchMultiplier,
      wheelMultiplier
    });
    this.virtualScroll.on("scroll", this.onVirtualScroll);
    if (this.options.autoToggle) {
      this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
        passive: true
      });
    }
    if (this.options.autoRaf) {
      this.__rafID = requestAnimationFrame(this.raf);
    }
  }
  /**
   * Destroy the lenis instance, remove all event listeners and clean up the class name
   */
  destroy() {
    this.emitter.destroy();
    this.options.wrapper.removeEventListener(
      "scroll",
      this.onNativeScroll,
      false
    );
    this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
      capture: true
    });
    this.options.wrapper.removeEventListener(
      "pointerdown",
      this.onPointerDown,
      false
    );
    if (this.options.anchors && this.options.wrapper === window) {
      this.options.wrapper.removeEventListener(
        "click",
        this.onClick,
        false
      );
    }
    this.virtualScroll.destroy();
    this.dimensions.destroy();
    this.cleanUpClassName();
    if (this.__rafID) {
      cancelAnimationFrame(this.__rafID);
    }
  }
  on(event, callback) {
    return this.emitter.on(event, callback);
  }
  off(event, callback) {
    return this.emitter.off(event, callback);
  }
  onScrollEnd = (e2) => {
    if (!(e2 instanceof CustomEvent)) {
      if (this.isScrolling === "smooth" || this.isScrolling === false) {
        e2.stopPropagation();
      }
    }
  };
  dispatchScrollendEvent = () => {
    this.options.wrapper.dispatchEvent(
      new CustomEvent("scrollend", {
        bubbles: this.options.wrapper === window,
        // cancelable: false,
        detail: {
          lenisScrollEnd: true
        }
      })
    );
  };
  onTransitionEnd = (event) => {
    if (event.propertyName.includes("overflow")) {
      const property = this.isHorizontal ? "overflow-x" : "overflow-y";
      const overflow = getComputedStyle(this.rootElement)[property];
      if (["hidden", "clip"].includes(overflow)) {
        this.internalStop();
      } else {
        this.internalStart();
      }
    }
  };
  setScroll(scroll) {
    if (this.isHorizontal) {
      this.options.wrapper.scrollTo({ left: scroll, behavior: "instant" });
    } else {
      this.options.wrapper.scrollTo({ top: scroll, behavior: "instant" });
    }
  }
  onClick = (event) => {
    const path = event.composedPath();
    const anchor = path.find(
      (node) => node instanceof HTMLAnchorElement && (node.getAttribute("href")?.startsWith("#") || node.getAttribute("href")?.startsWith("/#") || node.getAttribute("href")?.startsWith("./#"))
    );
    if (anchor) {
      const id = anchor.getAttribute("href");
      if (id) {
        const options = typeof this.options.anchors === "object" && this.options.anchors ? this.options.anchors : void 0;
        let target = `#${id.split("#")[1]}`;
        if (["#", "/#", "./#", "#top", "/#top", "./#top"].includes(id)) {
          target = 0;
        }
        this.scrollTo(target, options);
      }
    }
  };
  onPointerDown = (event) => {
    if (event.button === 1) {
      this.reset();
    }
  };
  onVirtualScroll = (data) => {
    if (typeof this.options.virtualScroll === "function" && this.options.virtualScroll(data) === false)
      return;
    const { deltaX, deltaY, event } = data;
    this.emitter.emit("virtual-scroll", { deltaX, deltaY, event });
    if (event.ctrlKey) return;
    if (event.lenisStopPropagation) return;
    const isTouch = event.type.includes("touch");
    const isWheel = event.type.includes("wheel");
    this.isTouching = event.type === "touchstart" || event.type === "touchmove";
    const isClickOrTap = deltaX === 0 && deltaY === 0;
    const isTapToStop = this.options.syncTouch && isTouch && event.type === "touchstart" && isClickOrTap && !this.isStopped && !this.isLocked;
    if (isTapToStop) {
      this.reset();
      return;
    }
    const isUnknownGesture = this.options.gestureOrientation === "vertical" && deltaY === 0 || this.options.gestureOrientation === "horizontal" && deltaX === 0;
    if (isClickOrTap || isUnknownGesture) {
      return;
    }
    let composedPath = event.composedPath();
    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));
    const prevent = this.options.prevent;
    if (!!composedPath.find(
      (node) => node instanceof HTMLElement && (typeof prevent === "function" && prevent?.(node) || node.hasAttribute?.("data-lenis-prevent") || isTouch && node.hasAttribute?.("data-lenis-prevent-touch") || isWheel && node.hasAttribute?.("data-lenis-prevent-wheel") || this.options.allowNestedScroll && this.checkNestedScroll(node, { deltaX, deltaY }))
    ))
      return;
    if (this.isStopped || this.isLocked) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;
    if (!isSmooth) {
      this.isScrolling = "native";
      this.animate.stop();
      event.lenisStopPropagation = true;
      return;
    }
    let delta = deltaY;
    if (this.options.gestureOrientation === "both") {
      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;
    } else if (this.options.gestureOrientation === "horizontal") {
      delta = deltaX;
    }
    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {
      event.lenisStopPropagation = true;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    const isSyncTouch = isTouch && this.options.syncTouch;
    const isTouchEnd = isTouch && event.type === "touchend";
    const hasTouchInertia = isTouchEnd;
    if (hasTouchInertia) {
      delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);
    }
    this.scrollTo(this.targetScroll + delta, {
      programmatic: false,
      ...isSyncTouch ? {
        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1
        // immediate: !hasTouchInertia,
      } : {
        lerp: this.options.lerp,
        duration: this.options.duration,
        easing: this.options.easing
      }
    });
  };
  /**
   * Force lenis to recalculate the dimensions
   */
  resize() {
    this.dimensions.resize();
    this.animatedScroll = this.targetScroll = this.actualScroll;
    this.emit();
  }
  emit() {
    this.emitter.emit("scroll", this);
  }
  onNativeScroll = () => {
    if (this._resetVelocityTimeout !== null) {
      clearTimeout(this._resetVelocityTimeout);
      this._resetVelocityTimeout = null;
    }
    if (this._preventNextNativeScrollEvent) {
      this._preventNextNativeScrollEvent = false;
      return;
    }
    if (this.isScrolling === false || this.isScrolling === "native") {
      const lastScroll = this.animatedScroll;
      this.animatedScroll = this.targetScroll = this.actualScroll;
      this.lastVelocity = this.velocity;
      this.velocity = this.animatedScroll - lastScroll;
      this.direction = Math.sign(
        this.animatedScroll - lastScroll
      );
      if (!this.isStopped) {
        this.isScrolling = "native";
      }
      this.emit();
      if (this.velocity !== 0) {
        this._resetVelocityTimeout = setTimeout(() => {
          this.lastVelocity = this.velocity;
          this.velocity = 0;
          this.isScrolling = false;
          this.emit();
        }, 400);
      }
    }
  };
  reset() {
    this.isLocked = false;
    this.isScrolling = false;
    this.animatedScroll = this.targetScroll = this.actualScroll;
    this.lastVelocity = this.velocity = 0;
    this.animate.stop();
  }
  /**
   * Start lenis scroll after it has been stopped
   */
  start() {
    if (!this.isStopped) return;
    if (this.options.autoToggle) {
      this.rootElement.style.removeProperty("overflow");
      return;
    }
    this.internalStart();
  }
  internalStart() {
    if (!this.isStopped) return;
    this.reset();
    this.isStopped = false;
    this.emit();
  }
  /**
   * Stop lenis scroll
   */
  stop() {
    if (this.isStopped) return;
    if (this.options.autoToggle) {
      this.rootElement.style.setProperty("overflow", "clip");
      return;
    }
    this.internalStop();
  }
  internalStop() {
    if (this.isStopped) return;
    this.reset();
    this.isStopped = true;
    this.emit();
  }
  /**
   * RequestAnimationFrame for lenis
   *
   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus
   */
  raf = (time2) => {
    const deltaTime = time2 - (this.time || time2);
    this.time = time2;
    this.animate.advance(deltaTime * 1e-3);
    if (this.options.autoRaf) {
      this.__rafID = requestAnimationFrame(this.raf);
    }
  };
  /**
   * Scroll to a target value
   *
   * @param target The target value to scroll to
   * @param options The options for the scroll
   *
   * @example
   * lenis.scrollTo(100, {
   *   offset: 100,
   *   duration: 1,
   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),
   *   lerp: 0.1,
   *   onStart: () => {
   *     console.log('onStart')
   *   },
   *   onComplete: () => {
   *     console.log('onComplete')
   *   },
   * })
   */
  scrollTo(target, {
    offset = 0,
    immediate = false,
    lock = false,
    duration = this.options.duration,
    easing = this.options.easing,
    lerp: lerp2 = this.options.lerp,
    onStart,
    onComplete,
    force = false,
    // scroll even if stopped
    programmatic = true,
    // called from outside of the class
    userData
  } = {}) {
    if ((this.isStopped || this.isLocked) && !force) return;
    if (typeof target === "string" && ["top", "left", "start"].includes(target)) {
      target = 0;
    } else if (typeof target === "string" && ["bottom", "right", "end"].includes(target)) {
      target = this.limit;
    } else {
      let node;
      if (typeof target === "string") {
        node = document.querySelector(target);
      } else if (target instanceof HTMLElement && target?.nodeType) {
        node = target;
      }
      if (node) {
        if (this.options.wrapper !== window) {
          const wrapperRect = this.rootElement.getBoundingClientRect();
          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;
        }
        const rect = node.getBoundingClientRect();
        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;
      }
    }
    if (typeof target !== "number") return;
    target += offset;
    target = Math.round(target);
    if (this.options.infinite) {
      if (programmatic) {
        this.targetScroll = this.animatedScroll = this.scroll;
        const distance = target - this.animatedScroll;
        if (distance > this.limit / 2) {
          target = target - this.limit;
        } else if (distance < -this.limit / 2) {
          target = target + this.limit;
        }
      }
    } else {
      target = clamp(0, target, this.limit);
    }
    if (target === this.targetScroll) {
      onStart?.(this);
      onComplete?.(this);
      return;
    }
    this.userData = userData ?? {};
    if (immediate) {
      this.animatedScroll = this.targetScroll = target;
      this.setScroll(this.scroll);
      this.reset();
      this.preventNextNativeScrollEvent();
      this.emit();
      onComplete?.(this);
      this.userData = {};
      requestAnimationFrame(() => {
        this.dispatchScrollendEvent();
      });
      return;
    }
    if (!programmatic) {
      this.targetScroll = target;
    }
    if (typeof duration === "number" && typeof easing !== "function") {
      easing = defaultEasing;
    } else if (typeof easing === "function" && typeof duration !== "number") {
      duration = 1;
    }
    this.animate.fromTo(this.animatedScroll, target, {
      duration,
      easing,
      lerp: lerp2,
      onStart: () => {
        if (lock) this.isLocked = true;
        this.isScrolling = "smooth";
        onStart?.(this);
      },
      onUpdate: (value, completed) => {
        this.isScrolling = "smooth";
        this.lastVelocity = this.velocity;
        this.velocity = value - this.animatedScroll;
        this.direction = Math.sign(this.velocity);
        this.animatedScroll = value;
        this.setScroll(this.scroll);
        if (programmatic) {
          this.targetScroll = value;
        }
        if (!completed) this.emit();
        if (completed) {
          this.reset();
          this.emit();
          onComplete?.(this);
          this.userData = {};
          requestAnimationFrame(() => {
            this.dispatchScrollendEvent();
          });
          this.preventNextNativeScrollEvent();
        }
      }
    });
  }
  preventNextNativeScrollEvent() {
    this._preventNextNativeScrollEvent = true;
    requestAnimationFrame(() => {
      this._preventNextNativeScrollEvent = false;
    });
  }
  checkNestedScroll(node, { deltaX, deltaY }) {
    const time2 = Date.now();
    const cache2 = node._lenis ??= {};
    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;
    const gestureOrientation = this.options.gestureOrientation;
    if (time2 - (cache2.time ?? 0) > 2e3) {
      cache2.time = Date.now();
      const computedStyle = window.getComputedStyle(node);
      cache2.computedStyle = computedStyle;
      const overflowXString = computedStyle.overflowX;
      const overflowYString = computedStyle.overflowY;
      hasOverflowX = ["auto", "overlay", "scroll"].includes(overflowXString);
      hasOverflowY = ["auto", "overlay", "scroll"].includes(overflowYString);
      cache2.hasOverflowX = hasOverflowX;
      cache2.hasOverflowY = hasOverflowY;
      if (!hasOverflowX && !hasOverflowY) return false;
      if (gestureOrientation === "vertical" && !hasOverflowY) return false;
      if (gestureOrientation === "horizontal" && !hasOverflowX) return false;
      scrollWidth = node.scrollWidth;
      scrollHeight = node.scrollHeight;
      clientWidth = node.clientWidth;
      clientHeight = node.clientHeight;
      isScrollableX = scrollWidth > clientWidth;
      isScrollableY = scrollHeight > clientHeight;
      cache2.isScrollableX = isScrollableX;
      cache2.isScrollableY = isScrollableY;
      cache2.scrollWidth = scrollWidth;
      cache2.scrollHeight = scrollHeight;
      cache2.clientWidth = clientWidth;
      cache2.clientHeight = clientHeight;
    } else {
      isScrollableX = cache2.isScrollableX;
      isScrollableY = cache2.isScrollableY;
      hasOverflowX = cache2.hasOverflowX;
      hasOverflowY = cache2.hasOverflowY;
      scrollWidth = cache2.scrollWidth;
      scrollHeight = cache2.scrollHeight;
      clientWidth = cache2.clientWidth;
      clientHeight = cache2.clientHeight;
    }
    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {
      return false;
    }
    if (gestureOrientation === "vertical" && (!hasOverflowY || !isScrollableY))
      return false;
    if (gestureOrientation === "horizontal" && (!hasOverflowX || !isScrollableX))
      return false;
    let orientation;
    if (gestureOrientation === "horizontal") {
      orientation = "x";
    } else if (gestureOrientation === "vertical") {
      orientation = "y";
    } else {
      const isScrollingX = deltaX !== 0;
      const isScrollingY = deltaY !== 0;
      if (isScrollingX && hasOverflowX && isScrollableX) {
        orientation = "x";
      }
      if (isScrollingY && hasOverflowY && isScrollableY) {
        orientation = "y";
      }
    }
    if (!orientation) return false;
    let scroll, maxScroll, delta, hasOverflow, isScrollable;
    if (orientation === "x") {
      scroll = node.scrollLeft;
      maxScroll = scrollWidth - clientWidth;
      delta = deltaX;
      hasOverflow = hasOverflowX;
      isScrollable = isScrollableX;
    } else if (orientation === "y") {
      scroll = node.scrollTop;
      maxScroll = scrollHeight - clientHeight;
      delta = deltaY;
      hasOverflow = hasOverflowY;
      isScrollable = isScrollableY;
    } else {
      return false;
    }
    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;
    return willScroll && hasOverflow && isScrollable;
  }
  /**
   * The root element on which lenis is instanced
   */
  get rootElement() {
    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;
  }
  /**
   * The limit which is the maximum scroll value
   */
  get limit() {
    if (this.options.__experimental__naiveDimensions) {
      if (this.isHorizontal) {
        return this.rootElement.scrollWidth - this.rootElement.clientWidth;
      } else {
        return this.rootElement.scrollHeight - this.rootElement.clientHeight;
      }
    } else {
      return this.dimensions.limit[this.isHorizontal ? "x" : "y"];
    }
  }
  /**
   * Whether or not the scroll is horizontal
   */
  get isHorizontal() {
    return this.options.orientation === "horizontal";
  }
  /**
   * The actual scroll value
   */
  get actualScroll() {
    const wrapper = this.options.wrapper;
    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;
  }
  /**
   * The current scroll value
   */
  get scroll() {
    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;
  }
  /**
   * The progress of the scroll relative to the limit
   */
  get progress() {
    return this.limit === 0 ? 1 : this.scroll / this.limit;
  }
  /**
   * Current scroll state
   */
  get isScrolling() {
    return this._isScrolling;
  }
  set isScrolling(value) {
    if (this._isScrolling !== value) {
      this._isScrolling = value;
      this.updateClassName();
    }
  }
  /**
   * Check if lenis is stopped
   */
  get isStopped() {
    return this._isStopped;
  }
  set isStopped(value) {
    if (this._isStopped !== value) {
      this._isStopped = value;
      this.updateClassName();
    }
  }
  /**
   * Check if lenis is locked
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(value) {
    if (this._isLocked !== value) {
      this._isLocked = value;
      this.updateClassName();
    }
  }
  /**
   * Check if lenis is smooth scrolling
   */
  get isSmooth() {
    return this.isScrolling === "smooth";
  }
  /**
   * The class name applied to the wrapper element
   */
  get className() {
    let className = "lenis";
    if (this.options.autoToggle) className += " lenis-autoToggle";
    if (this.isStopped) className += " lenis-stopped";
    if (this.isLocked) className += " lenis-locked";
    if (this.isScrolling) className += " lenis-scrolling";
    if (this.isScrolling === "smooth") className += " lenis-smooth";
    return className;
  }
  updateClassName() {
    this.cleanUpClassName();
    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();
  }
  cleanUpClassName() {
    this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim();
  }
};

// node_modules/@14islands/r3f-scroll-rig/dist/scrollrig.modern.js
function z() {
  return z = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2) Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, z.apply(this, arguments);
}
function Y(e2, t2) {
  if (null == e2) return {};
  var r2, n2, o2 = {}, l2 = Object.keys(e2);
  for (n2 = 0; n2 < l2.length; n2++) t2.indexOf(r2 = l2[n2]) >= 0 || (o2[r2] = e2[r2]);
  return o2;
}
function F(e2) {
  var t2 = function(e3, t3) {
    if ("object" != typeof e3 || null === e3) return e3;
    var r2 = e3[Symbol.toPrimitive];
    if (void 0 !== r2) {
      var n2 = r2.call(e3, "string");
      if ("object" != typeof n2) return n2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(e3);
  }(e2);
  return "symbol" == typeof t2 ? t2 : String(t2);
}
var Q = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
var q = { PRIORITY_PRELOAD: 0, PRIORITY_SCISSORS: 1, PRIORITY_VIEWPORTS: 1, PRIORITY_GLOBAL: 1e3, DEFAULT_SCALE_MULTIPLIER: 1, preloadQueue: [] };
var B = create((e2) => ({ debug: false, scaleMultiplier: q.DEFAULT_SCALE_MULTIPLIER, globalRender: true, globalPriority: q.PRIORITY_GLOBAL, globalClearDepth: false, globalRenderQueue: false, clearGlobalRenderQueue: () => e2(() => ({ globalRenderQueue: false })), isCanvasAvailable: false, hasSmoothScrollbar: false, canvasChildren: {}, renderToCanvas: (t2, r2, n2 = {}) => e2(({ canvasChildren: e3 }) => Object.getOwnPropertyDescriptor(e3, t2) ? (e3[t2].instances += 1, e3[t2].props.inactive = false, { canvasChildren: e3 }) : { canvasChildren: z({}, e3, { [t2]: { mesh: r2, props: n2, instances: 1 } }) }), updateCanvas: (t2, r2) => e2(({ canvasChildren: e3 }) => {
  if (!e3[t2]) return;
  const { [t2]: { mesh: n2, props: o2, instances: l2 } } = e3;
  return { canvasChildren: z({}, e3, { [t2]: { mesh: n2, props: z({}, o2, r2), instances: l2 } }) };
}), removeFromCanvas: (t2, r2 = true) => e2(({ canvasChildren: e3 }) => {
  var n2;
  return (null == (n2 = e3[t2]) ? void 0 : n2.instances) > 1 ? (e3[t2].instances -= 1, { canvasChildren: e3 }) : r2 ? { canvasChildren: Y(e3, [t2].map(F)) } : (e3[t2].instances = 0, e3[t2].props.inactive = true, { canvasChildren: z({}, e3) });
}), pageReflow: 0, requestReflow: () => {
  e2((e3) => ({ pageReflow: e3.pageReflow + 1 }));
}, scroll: { y: 0, x: 0, limit: 0, velocity: 0, progress: 0, direction: 0, scrollDirection: void 0 }, __lenis: void 0, scrollTo: () => {
}, onScroll: () => () => {
} }));
var W = () => {
  const e2 = B((e3) => e3.requestReflow), t2 = B((e3) => e3.debug);
  return (0, import_react.useEffect)(() => {
    let r2 = new (window.ResizeObserver || ResizeObserver2)(() => {
      e2(), t2 && console.log("ResizeManager", "document.body height changed");
    });
    return r2.observe(document.body), () => {
      null == r2 || r2.disconnect();
    };
  }, []), null;
};
var G = ["makeDefault", "margin"];
var H = (0, import_react.forwardRef)((t2, r2) => {
  let { makeDefault: n2 = false, margin: a2 = 0 } = t2, s2 = Y(t2, G);
  const c2 = useThree((e2) => e2.set), u2 = useThree((e2) => e2.camera), d2 = useThree((e2) => e2.size), p2 = useThree((e2) => e2.viewport), m = (0, import_react.useRef)(null);
  (0, import_react.useImperativeHandle)(r2, () => m.current);
  const g = B((e2) => e2.pageReflow), v = B((e2) => e2.scaleMultiplier), { fov: f, distance: w, aspect: b } = (0, import_react.useMemo)(() => {
    var e2;
    const t3 = (d2.height + 2 * a2) * v, r3 = (d2.width + 2 * a2) * v / t3;
    let n3 = s2.fov || 50, o2 = null == s2 || null == (e2 = s2.position) ? void 0 : e2[2];
    return o2 ? n3 = 180 / Math.PI * 2 * Math.atan(t3 / (2 * o2)) : o2 = t3 / (2 * Math.tan(n3 / 2 * Math.PI / 180)), { fov: n3, distance: o2, aspect: r3 };
  }, [d2, v, g]);
  return Q(() => {
    m.current.lookAt(0, 0, 0), m.current.updateProjectionMatrix(), m.current.updateMatrixWorld(), c2((e2) => ({ viewport: z({}, e2.viewport, p2.getCurrentViewport(u2)) }));
  }, [d2, v, g]), Q(() => {
    if (n2) {
      const e2 = u2;
      return c2(() => ({ camera: m.current })), () => c2(() => ({ camera: e2 }));
    }
  }, [m, n2, c2]), import_react.default.createElement("perspectiveCamera", z({ ref: m, position: [0, 0, w], onUpdate: (e2) => e2.updateProjectionMatrix(), near: 0.1, aspect: b, fov: f, far: 2 * w }, s2));
});
var X = ["makeDefault", "margin"];
var N = (0, import_react.forwardRef)((t2, r2) => {
  let { makeDefault: n2 = false, margin: a2 = 0 } = t2, s2 = Y(t2, X);
  const c2 = useThree((e2) => e2.set), u2 = useThree((e2) => e2.camera), d2 = useThree((e2) => e2.size), p2 = B((e2) => e2.pageReflow), m = B((e2) => e2.scaleMultiplier), g = (0, import_react.useMemo)(() => Math.max(d2.width * m, d2.height * m), [d2, p2, m]), v = (0, import_react.useRef)(null);
  return (0, import_react.useImperativeHandle)(r2, () => v.current), Q(() => {
    v.current.lookAt(0, 0, 0), v.current.updateProjectionMatrix(), v.current.updateMatrixWorld();
  }, [g, d2]), Q(() => {
    if (n2) {
      const e2 = u2;
      return c2(() => ({ camera: v.current })), () => c2(() => ({ camera: e2 }));
    }
  }, [v, n2, c2]), import_react.default.createElement("orthographicCamera", z({ left: d2.width * m / -2 - a2 * m, right: d2.width * m / 2 + a2 * m, top: d2.height * m / 2 + a2 * m, bottom: d2.height * m / -2 - a2 * m, far: 2 * g, position: [0, 0, g], near: 1e-3, ref: v, onUpdate: (e2) => e2.updateProjectionMatrix() }, s2));
});
function J(e2, t2) {
  e2 && (false === t2 ? (e2.wasFrustumCulled = e2.frustumCulled, e2.wasVisible = e2.visible, e2.visible = true, e2.frustumCulled = false) : (e2.visible = !!e2.wasVisible, e2.frustumCulled = !!e2.wasFrustumCulled), e2.children.forEach((e3) => J(e3, t2)));
}
var K = new Vector2();
var Z = (e2 = [0]) => {
  B.getState().globalRenderQueue = B.getState().globalRenderQueue || [0], B.getState().globalRenderQueue = [...B.getState().globalRenderQueue || [], ...e2];
};
var $ = ({ gl: e2, scene: t2, camera: r2, left: n2, top: o2, width: l2, height: i2, layer: a2 = 0, autoClear: s2 = false, clearDepth: c2 = false }) => {
  t2 && r2 && (e2.autoClear = s2, e2.setScissor(n2, o2, l2, i2), e2.setScissorTest(true), r2.layers.set(a2), c2 && e2.clearDepth(), e2.render(t2, r2), e2.setScissorTest(false));
};
var ee = ({ gl: e2, scene: t2, camera: r2, left: n2, top: o2, width: l2, height: i2, layer: a2 = 0, scissor: s2 = true, autoClear: c2 = false, clearDepth: u2 = false }) => {
  t2 && r2 && (e2.getSize(K), e2.autoClear = c2, e2.setViewport(n2, o2, l2, i2), e2.setScissor(n2, o2, l2, i2), e2.setScissorTest(s2), r2.layers.set(a2), u2 && e2.clearDepth(), e2.render(t2, r2), e2.setScissorTest(false), e2.setViewport(0, 0, K.x, K.y));
};
var te = ({ scene: e2, camera: t2, layer: r2 = 0 }, n2) => {
  q.preloadQueue.push((o2, l2, i2) => {
    o2.setScissorTest(false), J(e2 || l2, false), (t2 || i2).layers.set(r2), o2.render(e2 || l2, t2 || i2), J(e2 || l2, true), n2 && n2();
  }), invalidate();
};
var re = () => {
  const e2 = B((e3) => e3.isCanvasAvailable), t2 = B((e3) => e3.hasSmoothScrollbar), n2 = B((e3) => e3.requestReflow), o2 = B((e3) => e3.pageReflow), l2 = B((e3) => e3.debug), i2 = B((e3) => e3.scaleMultiplier);
  return (0, import_react.useEffect)(() => {
    l2 && (window._scrollRig = window._scrollRig || {}, window._scrollRig.reflow = n2);
  }, []), { debug: l2, isCanvasAvailable: e2, hasSmoothScrollbar: t2, scaleMultiplier: i2, preloadScene: te, requestRender: Z, renderScissor: $, renderViewport: ee, reflow: n2, reflowCompleted: o2 };
};
var ne = ({ children: t2 }) => {
  const n2 = useThree((e2) => e2.gl), o2 = B((e2) => e2.canvasChildren), l2 = re();
  return (0, import_react.useEffect)(() => {
    Object.keys(o2).length || (l2.debug && console.log("GlobalRenderer", "auto render empty canvas"), n2.clear(), l2.requestRender(), invalidate());
  }, [o2]), l2.debug && console.log("GlobalChildren", Object.keys(o2).length), import_react.default.createElement(import_react.default.Fragment, null, t2, Object.keys(o2).map((t3) => {
    const { mesh: r2, props: n3 } = o2[t3];
    return "function" == typeof r2 ? import_react.default.createElement(import_react.Fragment, { key: t3 }, r2(z({ key: t3 }, l2, n3))) : (0, import_react.cloneElement)(r2, z({ key: t3 }, n3));
  }));
};
var oe = () => {
  const e2 = useThree((e3) => e3.gl), t2 = useThree((e3) => e3.frameloop), r2 = B((e3) => e3.globalClearDepth), n2 = B((e3) => e3.globalPriority), o2 = re();
  return Q(() => {
    e2.debug.checkShaderErrors = o2.debug;
  }, [o2.debug]), useFrame(({ camera: t3, scene: r3 }) => {
    q.preloadQueue.length && (q.preloadQueue.forEach((n3) => n3(e2, r3, t3)), e2.clear(), q.preloadQueue = [], o2.debug && console.log("GlobalRenderer", "preload complete. trigger global render"), o2.requestRender(), invalidate());
  }, q.PRIORITY_PRELOAD), useFrame(({ camera: n3, scene: o3 }) => {
    const l2 = B.getState().globalRenderQueue;
    ("always" === t2 || l2) && (n3.layers.disableAll(), l2 ? l2.forEach((e3) => {
      n3.layers.enable(e3);
    }) : n3.layers.enable(0), r2 && e2.clearDepth(), e2.render(o3, n3)), B.getState().clearGlobalRenderQueue();
  }, n2), null;
};
var le = class extends import_react.Component {
  constructor(e2) {
    super(e2), this.state = { error: false }, this.props = e2;
  }
  static getDerivedStateFromError(e2) {
    return { error: e2 };
  }
  render() {
    return this.state.error ? (this.props.onError && this.props.onError(this.state.error), null) : this.props.children;
  }
};
var ie = "8.14.0";
var ae = ["children", "as", "gl", "style", "orthographic", "camera", "debug", "scaleMultiplier", "globalRender", "globalPriority", "globalClearDepth"];
var se = ["children", "onError"];
var ce;
"undefined" != typeof window && (ce = window.ResizeObserver || ResizeObserver2);
var ue = (t2) => {
  let { children: r2, as: n2 = Canvas, gl: o2, style: l2, orthographic: i2, camera: a2, debug: s2, scaleMultiplier: c2 = q.DEFAULT_SCALE_MULTIPLIER, globalRender: d2 = true, globalPriority: p2 = q.PRIORITY_GLOBAL, globalClearDepth: h = false } = t2, m = Y(t2, ae);
  const g = B((e2) => e2.globalRender);
  return Q(() => {
    "undefined" != typeof window && (window.__r3f_scroll_rig = ie);
    const e2 = (0, import_query_string.parse)(window.location.search);
    (s2 || void 0 !== e2.debug) && (B.setState({ debug: true }), console.info("@14islands/r3f-scroll-rig@" + ie));
  }, [s2]), Q(() => {
    (0, import_react.startTransition)(() => {
      B.setState({ scaleMultiplier: c2, globalRender: d2, globalPriority: p2, globalClearDepth: h });
    });
  }, [c2, p2, d2, h]), import_react.default.createElement(n2, z({ id: "ScrollRig-canvas", camera: { manual: true }, gl: z({ failIfMajorPerformanceCaveat: true }, o2), resize: { scroll: false, debounce: 0, polyfill: ce }, style: z({ position: "fixed", top: 0, left: 0, right: 0, height: "100vh" }, l2) }, m), !i2 && import_react.default.createElement(H, z({ manual: true, makeDefault: true }, a2)), i2 && import_react.default.createElement(N, z({ manual: true, makeDefault: true }, a2)), g && import_react.default.createElement(oe, null), "function" == typeof r2 ? r2(import_react.default.createElement(ne, null)) : import_react.default.createElement(ne, null, r2), import_react.default.createElement(W, null));
};
var de = (t2) => {
  let { children: r2, onError: n2 } = t2, o2 = Y(t2, se);
  return Q(() => {
    document.documentElement.classList.add("js-has-global-canvas"), B.setState({ isCanvasAvailable: true });
  }, []), import_react.default.createElement(le, { onError: (e2) => {
    n2 && n2(e2), B.setState({ isCanvasAvailable: false }), document.documentElement.classList.remove("js-has-global-canvas"), document.documentElement.classList.add("js-global-canvas-error");
  } }, import_react.default.createElement(ue, z({}, o2), r2), import_react.default.createElement("noscript", null, import_react.default.createElement("style", null, "\n          .ScrollRig-visibilityHidden,\n          .ScrollRig-transparentColor {\n            visibility: unset;\n            color: unset;\n          }\n          ")));
};
var pe = ({ scale: t2 }) => import_react.default.createElement("mesh", { scale: t2 }, import_react.default.createElement("planeGeometry", null), import_react.default.createElement("shaderMaterial", { args: [{ uniforms: { color: { value: new Color("hotpink") } }, vertexShader: "\n            void main() {\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n          ", fragmentShader: "\n            uniform vec3 color;\n            uniform float opacity;\n            void main() {\n              gl_FragColor.rgba = vec4(color, .5);\n            }\n          " }], transparent: true }));
var he = "undefined" != typeof window;
function me({ debounce: e2 = 0 } = {}) {
  const [t2, n2] = (0, import_react.useState)({ width: he ? window.innerWidth : Infinity, height: he ? window.innerHeight : Infinity });
  return (0, import_react.useEffect)(() => {
    const r2 = document.getElementById("ScrollRig-canvas");
    function o2() {
      const e3 = r2 ? r2.clientWidth : window.innerWidth, o3 = r2 ? r2.clientHeight : window.innerHeight;
      e3 === t2.width && o3 === t2.height || n2({ width: e3, height: o3 });
    }
    const l2 = import_debounce.default.debounce(o2, e2), i2 = window.ResizeObserver || ResizeObserver2;
    let a2;
    return r2 ? (a2 = new i2(l2), a2.observe(r2)) : window.addEventListener("resize", l2), o2(), () => {
      var e3;
      window.removeEventListener("resize", l2), null == (e3 = a2) || e3.disconnect();
    };
  }, [t2, n2]), t2;
}
function ge(e2, t2, r2, n2, o2) {
  return n2 + (e2 - t2) * (o2 - n2) / (r2 - t2);
}
var ve = () => ({ enabled: B((e2) => e2.hasSmoothScrollbar), scroll: B((e2) => e2.scroll), scrollTo: B((e2) => e2.scrollTo), onScroll: B((e2) => e2.onScroll), __lenis: B((e2) => e2.__lenis) });
function fe(e2, t2) {
  const n2 = me(), { scroll: l2, onScroll: a2 } = ve(), s2 = B((e3) => e3.scaleMultiplier), c2 = B((e3) => e3.pageReflow), u2 = B((e3) => e3.debug), { rootMargin: h, threshold: m, autoUpdate: g, wrapper: v } = (0, import_react.useMemo)(() => {
    const e3 = { rootMargin: "0%", threshold: 0, autoUpdate: true }, r2 = t2 || {};
    return Object.keys(r2).map((t3, n3) => {
      void 0 !== r2[t3] && (e3[t3] = r2[t3]);
    }), e3;
  }, [t2]), { ref: f, inView: w } = useInView({ rootMargin: h, threshold: m });
  Q(() => {
    f(e2.current);
  }, [e2, null == e2 ? void 0 : e2.current]);
  const [b, y] = (0, import_react.useState)(import_vecn.default.vec3(0, 0, 0)), S2 = (0, import_react.useRef)({ inViewport: false, progress: -1, visibility: -1, viewport: -1 }).current, R = (0, import_react.useRef)({ top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 }).current, [E, C] = (0, import_react.useState)(R), T = (0, import_react.useRef)({ top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0, x: 0, y: 0, positiveYUpBottom: 0 }).current, I = (0, import_react.useRef)(import_vecn.default.vec3(0, 0, 0)).current;
  Q(() => {
    var t3;
    const r2 = null == (t3 = e2.current) ? void 0 : t3.getBoundingClientRect();
    if (!r2) return;
    const o2 = v ? v.scrollTop : window.scrollY, l3 = v ? v.scrollLeft : window.scrollX;
    R.top = r2.top + o2, R.bottom = r2.bottom + o2, R.left = r2.left + l3, R.right = r2.right + l3, R.width = r2.width, R.height = r2.height, C(z({}, R)), y(import_vecn.default.vec3((null == R ? void 0 : R.width) * s2, (null == R ? void 0 : R.height) * s2, 1)), u2 && console.log("useTracker.getBoundingClientRect:", R, "intialScroll:", { initialY: o2, initialX: l3 }, "size:", n2, "pageReflow:", c2);
  }, [e2, n2, c2, s2, u2]);
  const O = (0, import_react.useCallback)(({ onlyUpdateInViewport: t3 = false, scroll: r2 } = {}) => {
    if (!e2.current || t3 && !S2.inViewport) return;
    const o2 = r2 || l2;
    !function(e3, t4, r3, n3) {
      e3.top = t4.top - (r3.y || 0), e3.bottom = t4.bottom - (r3.y || 0), e3.left = t4.left - (r3.x || 0), e3.right = t4.right - (r3.x || 0), e3.width = t4.width, e3.height = t4.height, e3.x = e3.left + 0.5 * t4.width - 0.5 * n3.width, e3.y = e3.top + 0.5 * t4.height - 0.5 * n3.height, e3.positiveYUpBottom = n3.height - e3.bottom;
    }(T, R, o2, n2), function(e3, t4, r3) {
      e3.x = t4.x * r3, e3.y = -1 * t4.y * r3;
    }(I, T, s2);
    const i2 = "horizontal" === o2.scrollDirection, a3 = i2 ? "width" : "height", c3 = n2[a3] - T[i2 ? "left" : "top"];
    S2.progress = ge(c3, 0, n2[a3] + T[a3], 0, 1), S2.visibility = ge(c3, 0, T[a3], 0, 1), S2.viewport = ge(c3, 0, n2[a3], 0, 1);
  }, [e2, n2, s2, l2]);
  return Q(() => {
    S2.inViewport = w, O({ onlyUpdateInViewport: false }), u2 && console.log("useTracker.inViewport:", w, "update()");
  }, [w]), Q(() => {
    O({ onlyUpdateInViewport: false }), u2 && console.log("useTracker.update on resize/reflow");
  }, [O, c2]), (0, import_react.useEffect)(() => {
    if (g) return a2((e3) => O({ onlyUpdateInViewport: true }));
  }, [g, O, a2]), { scale: b, inViewport: w, rect: E, bounds: T, position: I, scrollState: S2, update: O };
}
var we = ["track", "children", "margin", "inViewportMargin", "inViewportThreshold", "visible", "hideOffscreen", "scissor", "debug", "as", "priority", "scene"];
function be(t2) {
  let { track: n2, children: l2, margin: i2 = 0, inViewportMargin: a2, inViewportThreshold: s2, visible: c2 = true, hideOffscreen: u2 = true, scissor: p2 = false, debug: m = false, as: v = "scene", priority: w = q.PRIORITY_SCISSORS, scene: b } = t2, y = Y(t2, we);
  const S2 = useThree((e2) => e2.scene), R = (0, import_react.useRef)(), [E] = (0, import_react.useState)(b || (p2 ? new Scene() : null)), { requestRender: C, renderScissor: I } = re(), O = B((e2) => e2.globalRender), { bounds: L, scale: M, position: k, scrollState: _, inViewport: x } = fe(n2, { rootMargin: a2, threshold: s2 });
  Q(() => {
    R.current && (R.current.visible = u2 ? x && c2 : c2);
  }, [x, u2, c2]), (0, import_react.useEffect)(() => {
    R.current && (R.current.position.y = k.y, R.current.position.x = k.x);
  }, [M, x]), useFrame(({ gl: e2, camera: t3 }) => {
    R.current && R.current.visible && (R.current.position.y = k.y, R.current.position.x = k.x, p2 ? I({ gl: e2, portalScene: E, camera: t3, left: L.left - i2, top: L.positiveYUpBottom - i2, width: L.width + 2 * i2, height: L.height + 2 * i2 }) : C());
  }, O ? w : void 0);
  const P2 = import_react.default.createElement(v, { ref: R }, (!l2 || m) && M && import_react.default.createElement(pe, { scale: M }), l2 && M && l2(z({ track: n2, margin: i2, scene: E || S2, scale: M, scrollState: _, inViewport: x, priority: w }, y)));
  return E ? createPortal(P2, E) : P2;
}
var ye = ["track", "children", "margin", "visible", "hideOffscreen", "debug", "orthographic", "priority", "inViewport", "bounds", "scale", "scrollState", "camera", "hud", "position", "rect"];
var Se = ["track", "margin", "inViewportMargin", "inViewportThreshold", "priority"];
var Re = ["bounds"];
var Ee = (t2) => {
  let { track: n2, children: o2, margin: l2 = 0, visible: i2 = true, hideOffscreen: a2 = true, debug: s2 = false, orthographic: c2 = false, priority: u2 = q.PRIORITY_VIEWPORTS, inViewport: d2, bounds: p2, scale: m, scrollState: v, camera: f, hud: w } = t2, b = Y(t2, ye);
  const y = useThree((e2) => e2.scene), S2 = useThree((e2) => e2.get), R = useThree((e2) => e2.setEvents), { renderViewport: E } = re();
  return Q(() => {
    y.visible = a2 ? d2 && i2 : i2;
  }, [d2, a2, i2]), (0, import_react.useEffect)(() => {
    const e2 = S2().events.connected;
    return R({ connected: n2.current }), () => R({ connected: e2 });
  }, []), useFrame(({ gl: e2, scene: t3, camera: r2 }) => {
    t3.visible && E({ gl: e2, scene: t3, camera: r2, left: p2.left - l2, top: p2.positiveYUpBottom - l2, width: p2.width + 2 * l2, height: p2.height + 2 * l2, clearDepth: !!w });
  }, u2), import_react.default.createElement(import_react.default.Fragment, null, !c2 && import_react.default.createElement(H, z({ manual: true, margin: l2, makeDefault: true }, f)), c2 && import_react.default.createElement(N, z({ manual: true, margin: l2, makeDefault: true }, f)), (!o2 || s2) && m && import_react.default.createElement(pe, { scale: m }), o2 && m && o2(z({ track: n2, margin: l2, scale: m, scrollState: v, inViewport: d2, priority: u2 }, b)));
};
function Ce(t2) {
  let { track: r2, margin: n2 = 0, inViewportMargin: o2, inViewportThreshold: l2, priority: i2 } = t2, a2 = Y(t2, Se);
  const [s2] = (0, import_react.useState)(() => new Scene()), c2 = fe(r2, { rootMargin: o2, threshold: l2 }), { bounds: u2 } = c2, h = Y(c2, Re), m = (0, import_react.useCallback)((e2, t3) => {
    if (r2.current && e2.target === r2.current) {
      const { width: r3, height: o3, left: l3, top: i3 } = u2;
      t3.pointer.set((e2.clientX - l3 + n2) / (r3 + 2 * n2) * 2 - 1, -(e2.clientY - i3 + n2) / (o3 + 2 * n2) * 2 + 1), t3.raycaster.setFromCamera(t3.pointer, t3.camera);
    }
  }, [u2]);
  return u2 && createPortal(import_react.default.createElement(Ee, z({ track: r2, bounds: u2, priority: i2, margin: n2 }, a2, h)), s2, { events: { compute: m, priority: i2 }, size: { width: u2.width, height: u2.height } });
}
function Te(e2, t2 = {}, { key: n2, dispose: o2 = true } = {}) {
  const l2 = B((e3) => e3.updateCanvas), a2 = B((e3) => e3.renderToCanvas), s2 = B((e3) => e3.removeFromCanvas), c2 = (0, import_react.useMemo)(() => n2 || MathUtils.generateUUID(), []);
  Q(() => {
    a2(c2, e2, z({}, t2, { inactive: false }));
  }, [c2]), (0, import_react.useEffect)(() => () => {
    s2(c2, o2);
  }, [c2]);
  const u2 = (0, import_react.useCallback)((e3) => {
    l2(c2, e3);
  }, [l2, c2]);
  return (0, import_react.useEffect)(() => {
    u2(t2);
  }, [...Object.values(t2)]), u2;
}
var Ie = ["children", "id", "dispose"];
var Oe = (0, import_react.forwardRef)((e2, t2) => {
  let { children: r2, id: n2, dispose: o2 = true } = e2, l2 = Y(e2, Ie);
  return r2 ? (Te(r2, z({}, l2, { id: n2, ref: t2 }), { key: n2, dispose: o2 }), null) : null;
});
var Le = false;
function Me(e2, { initTexture: t2 = true, premultiplyAlpha: n2 = "default" } = {}) {
  var o2, l2;
  const a2 = useThree((e3) => e3.gl), s2 = me(), c2 = B((e3) => e3.debug), [u2, p2] = (0, import_react.useState)(null == (o2 = e2.current) ? void 0 : o2.currentSrc);
  (0, import_react.useEffect)(() => {
    const t3 = e2.current, r2 = () => {
      var t4;
      p2(null == (t4 = e2.current) ? void 0 : t4.currentSrc);
    };
    return null == t3 || t3.addEventListener("load", r2), () => null == t3 ? void 0 : t3.removeEventListener("load", r2);
  }, [e2, u2, p2]);
  const m = suspend(() => (DefaultLoadingManager.itemStart("waiting for DOM image"), new Promise((t3) => {
    const r2 = e2.current;
    function n3() {
      t3(null == r2 ? void 0 : r2.currentSrc), DefaultLoadingManager.itemEnd("waiting for DOM image");
    }
    null == r2 || r2.addEventListener("load", n3, { once: true }), null != r2 && r2.complete && (null == r2 || r2.removeEventListener("load", n3), n3());
  })), [e2, s2, null == (l2 = e2.current) ? void 0 : l2.currentSrc, u2], { equal: import_fast_deep_equal.default }), g = function() {
    const e3 = true === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), t3 = navigator.userAgent.indexOf("Firefox") > -1, r2 = t3 ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    return "undefined" == typeof createImageBitmap || e3 || t3 && Number(r2) < 98;
  }() ? TextureLoader : ImageBitmapLoader, v = useLoader(g, m, (e3) => {
    e3 instanceof ImageBitmapLoader && (e3.setOptions({ colorSpaceConversion: "none", premultiplyAlpha: n2, imageOrientation: "flipY" }), e3.setRequestHeader({ Accept: (Le ? "image/webp," : "") + "*/*" }));
  }), f = (0, import_react.useMemo)(() => v instanceof Texture ? v : v instanceof ImageBitmap ? new CanvasTexture(v) : void 0, [v]);
  return (0, import_react.useEffect)(function() {
    t2 && a2.initTexture(f), c2 && console.log("useImageAsTexture", "initTexture()");
  }, [a2, f, t2]), f;
}
supports_webp_default.then((e2) => {
  Le = e2;
});
var ke = (0, import_react.forwardRef)(({ children: e2, enabled: t2 = true, locked: n2 = false, scrollRestoration: i2 = "auto", disablePointerOnScroll: a2 = true, horizontal: s2 = false, scrollInContainer: c2 = false, updateGlobalState: u2 = true, onScroll: d2, config: h = {}, invalidate: m = () => {
}, addEffect: g }, v) => {
  const f = (0, import_react.useRef)(), w = (0, import_react.useRef)(false), b = B((e3) => e3.scroll);
  (0, import_react.useImperativeHandle)(v, () => ({ start: () => {
    var e3;
    return null == (e3 = f.current) ? void 0 : e3.start();
  }, stop: () => {
    var e3;
    return null == (e3 = f.current) ? void 0 : e3.stop();
  }, on: (e3, t3) => {
    var r2;
    return null == (r2 = f.current) ? void 0 : r2.on(e3, t3);
  }, scrollTo: (e3, t3) => {
    var r2;
    return null == (r2 = f.current) ? void 0 : r2.scrollTo(e3, t3);
  }, raf: (e3) => {
    var t3;
    return null == (t3 = f.current) ? void 0 : t3.raf(e3);
  }, __lenis: f.current }));
  const y = (0, import_react.useCallback)((e3) => {
    a2 && w.current !== e3 && (w.current = e3, document.documentElement.style.pointerEvents = e3 ? "none" : "auto");
  }, [a2, w]);
  return Q(() => {
    "scrollRestoration" in window.history && (window.history.scrollRestoration = i2);
  }, []), Q(() => {
    const e3 = document.documentElement, r2 = document.body, n3 = document.body.firstElementChild;
    let o2;
    if (e3.classList.toggle("ScrollRig-scrollHtml", c2), r2.classList.toggle("ScrollRig-scrollWrapper", c2), c2 && Object.assign(h, { smoothTouch: true, wrapper: r2, content: n3 }), f.current = new Lenis(z({ orientation: s2 ? "horizontal" : "vertical" }, h, t2 ? {} : { smoothWheel: false, syncTouch: false, smoothTouch: false })), g) o2 = g((e4) => {
      var t3;
      return null == (t3 = f.current) ? void 0 : t3.raf(e4);
    });
    else {
      let e4;
      e4 = requestAnimationFrame(function t3(r3) {
        var n4;
        null == (n4 = f.current) || n4.raf(r3), e4 = requestAnimationFrame(t3);
      }), o2 = () => cancelAnimationFrame(e4);
    }
    return () => {
      var e4;
      o2(), null == (e4 = f.current) || e4.destroy();
    };
  }, [t2]), Q(() => {
    const e3 = f.current, t3 = ({ scroll: e4, limit: t4, velocity: r2, direction: n3, progress: o2 }) => {
      const l2 = s2 ? e4 : 0;
      u2 && (b.y = s2 ? 0 : e4, b.x = l2, b.limit = t4, b.velocity = r2, b.direction = n3, b.progress = o2 || 0), Math.abs(r2) > 1.5 && y(true), Math.abs(r2) < 1 && y(false), d2 && d2({ scroll: e4, limit: t4, velocity: r2, direction: n3, progress: o2 }), m();
    };
    return null == e3 || e3.on("scroll", t3), u2 && (b.scrollDirection = s2 ? "horizontal" : "vertical", B.setState({ __lenis: e3, scrollTo: (...t4) => {
      null == e3 || e3.scrollTo(...t4);
    }, onScroll: (t4) => (null == e3 || e3.on("scroll", t4), null == e3 || e3.emit(), () => null == e3 ? void 0 : e3.off("scroll", t4)) }), B.getState().scroll.y = window.scrollY, B.getState().scroll.x = window.scrollX), null == e3 || e3.emit(), () => {
      null == e3 || e3.off("scroll", t3), u2 && B.setState({ __lenis: void 0, onScroll: () => () => {
      }, scrollTo: () => {
      } });
    };
  }, [t2]), Q(() => {
    const e3 = () => m(), t3 = () => y(false);
    return window.addEventListener("pointermove", t3), window.addEventListener("pointerdown", t3), window.addEventListener("wheel", e3), () => {
      window.removeEventListener("pointermove", t3), window.removeEventListener("pointerdown", t3), window.removeEventListener("wheel", e3);
    };
  }, []), (0, import_react.useEffect)(() => (u2 && (document.documentElement.classList.toggle("js-smooth-scrollbar-enabled", t2), document.documentElement.classList.toggle("js-smooth-scrollbar-disabled", !t2), B.setState({ hasSmoothScrollbar: t2 })), () => {
    document.documentElement.classList.remove("js-smooth-scrollbar-enabled"), document.documentElement.classList.remove("js-smooth-scrollbar-disabled");
  }), [t2]), (0, import_react.useEffect)(() => {
    var e3, t3;
    n2 ? null == (e3 = f.current) || e3.stop() : null == (t3 = f.current) || t3.start();
  }, [n2]), e2 ? e2({}) : null;
});
var _e = (0, import_react.forwardRef)(function(t2, r2) {
  const n2 = B((e2) => e2.isCanvasAvailable);
  return import_react.default.createElement(ke, z(n2 ? { key: "r3f", ref: r2, invalidate, addEffect } : { key: "native", ref: r2 }, t2));
});
var xe = { hidden: "ScrollRig-visibilityHidden", hiddenWhenSmooth: "ScrollRig-visibilityHidden ScrollRig-hiddenIfSmooth", transparentColor: "ScrollRig-transparentColor", transparentColorWhenSmooth: "ScrollRig-transparentColor ScrollRig-hiddenIfSmooth" };

export {
  B,
  re,
  de,
  me,
  ve,
  fe,
  be,
  Ce,
  Te,
  Oe,
  Me,
  _e,
  xe
};
//# sourceMappingURL=chunk-OIRLFBLV.js.map
