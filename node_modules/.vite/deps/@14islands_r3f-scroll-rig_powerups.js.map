{
  "version": 3,
  "sources": ["../../@14islands/r3f-scroll-rig/powerups/WebGLText.tsx", "../../@14islands/r3f-scroll-rig/powerups/WebGLImage.tsx", "../../@14islands/r3f-scroll-rig/powerups/ParallaxScrollScene.tsx", "../../@14islands/node_modules/vecn/src/index.js", "../../@14islands/r3f-scroll-rig/powerups/StickyScrollScene.tsx", "../../@14islands/node_modules/@14islands/lerp/index.js", "../../@14islands/node_modules/lerp/index.js"],
  "sourcesContent": ["import React, { useMemo, useEffect, ReactNode, MutableRefObject } from 'react'\nimport { Color, Material } from 'three'\nimport { useThree } from '@react-three/fiber'\nimport { Text } from '@react-three/drei'\n\nimport { useScrollRig } from '@14islands/r3f-scroll-rig'\n\n/**\n * Returns a WebGL Troika text mesh styled as the source DOM element\n */\n\ninterface WebGLTextProps {\n  el: MutableRefObject<HTMLElement>\n  children?: ReactNode\n  material?: Material\n  scale?: any\n  font?: string\n  fontOffsetY?: number\n  fontOffsetX?: number\n  overrideEmissive?: boolean\n  color?: string\n}\n\nexport const WebGLText = ({\n  el,\n  children,\n  material,\n  scale,\n  font,\n  fontOffsetY = 0,\n  fontOffsetX = 0,\n  overrideEmissive = false,\n  color,\n  ...props\n}: WebGLTextProps) => {\n  const { size } = useThree()\n  const { scaleMultiplier } = useScrollRig()\n\n  const { textColor, fontSize, textAlign, lineHeight, letterSpacing } = useMemo(() => {\n    if (!el.current) return {}\n    const cs = window.getComputedStyle(el.current)\n\n    // get color from parent if set to transparent\n    let textColor = color || cs.color\n    if (!color && cs.color === 'rgba(0, 0, 0, 0)' && el.current.parentElement) {\n      textColor = window.getComputedStyle(el.current.parentElement).color\n    }\n\n    // font size relative letter spacing\n    const letterSpacing = (parseFloat(cs.letterSpacing) || 0) / parseFloat(cs.fontSize)\n    const lineHeight = (parseFloat(cs.lineHeight) || 0) / parseFloat(cs.fontSize)\n\n    return {\n      letterSpacing,\n      lineHeight,\n      textColor,\n      fontSize: parseFloat(cs.fontSize) * scaleMultiplier,\n      textAlign: cs.textAlign,\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [el, size, scale, color, scaleMultiplier]) // recalc on resize\n\n  useEffect(() => {\n    if (material && overrideEmissive) {\n      // @ts-ignore\n      material.emissive = color\n    }\n  }, [material, color, overrideEmissive])\n\n  let xOffset = 0\n  if (textAlign === 'left' || textAlign === 'start') {\n    xOffset = scale[0] * -0.5\n  } else if (textAlign === 'right' || textAlign === 'end') {\n    xOffset = scale[0] * 0.5\n  }\n\n  const yOffset = scale ? scale[1] * 0.5 : size.height * 0.5\n\n  return (\n    <Text\n      fontSize={fontSize}\n      maxWidth={scale ? scale[0] : size.width}\n      lineHeight={lineHeight}\n      // @ts-ignore\n      textAlign={textAlign}\n      letterSpacing={letterSpacing}\n      overflowWrap=\"break-word\"\n      font={font}\n      color={textColor}\n      // @ts-ignore\n      anchorX={textAlign}\n      anchorY=\"top\" // so text moves down if row breaks\n      // @ts-ignore\n      position={[xOffset + fontSize * fontOffsetX, yOffset + fontSize * fontOffsetY, 0]} // font specific\n      material={material}\n      {...props}\n    >\n      {children}\n    </Text>\n  )\n}\n", "import React, {\n  useRef,\n  useMemo,\n  useEffect,\n  forwardRef,\n  MutableRefObject,\n  ForwardedRef,\n  useImperativeHandle,\n} from 'react'\nimport { Color, Vector2, ShaderMaterial, Mesh, ShaderMaterialParameters } from 'three'\nimport { useFrame, useThree } from '@react-three/fiber'\n\nimport { useScrollRig, useImageAsTexture, useScrollbar } from '@14islands/r3f-scroll-rig'\n\ninterface WebGLImageProps {\n  el: MutableRefObject<HTMLImageElement>\n  scale?: any\n  scrollState?: any\n  vertexShader?: string\n  fragmentShader?: string\n  invalidateFrameLoop: boolean\n  widthSegments?: number\n  heightSegments?: number\n}\n\nexport const WebGLImage = forwardRef(\n  (\n    {\n      el,\n      scale,\n      scrollState,\n      vertexShader,\n      fragmentShader,\n      invalidateFrameLoop = false,\n      widthSegments = 128,\n      heightSegments = 128,\n      ...props\n    }: WebGLImageProps,\n    ref: ForwardedRef<Mesh>\n  ) => {\n    const material = useRef<ShaderMaterial>(null!)\n    const mesh = useRef<Mesh>(null!)\n    useImperativeHandle(ref, () => mesh.current)\n\n    const { invalidate, gl, size } = useThree()\n    const pixelRatio = useThree((s) => s.viewport.dpr)\n    const { scroll } = useScrollbar()\n    const { scaleMultiplier } = useScrollRig()\n\n    const texture = useImageAsTexture(el)\n\n    const uniforms = useMemo(() => {\n      return {\n        u_color: { value: new Color('black') },\n        u_time: { value: 0 },\n        u_pixelRatio: { value: pixelRatio },\n        u_progress: { value: 0 },\n        u_visibility: { value: 0 },\n        u_viewport: { value: 0 },\n        u_velocity: { value: 0 }, // scroll speed\n        u_res: { value: new Vector2() }, // screen dimensions\n        u_rect: { value: new Vector2() }, // DOM el dimensions\n        u_size: { value: new Vector2() }, // Texture dimensions\n        u_texture: { value: null },\n        u_loaded: { value: false },\n        u_scaleMultiplier: { value: scaleMultiplier },\n      }\n    }, [pixelRatio])\n\n    // Fade in when texture loaded\n    useEffect(() => {\n      if (!texture) return\n      if (!material.current) return\n      material.current.uniforms.u_texture.value = texture\n      material.current.uniforms.u_size.value.set(texture.image.width, texture.image.height)\n      material.current.uniforms.u_loaded.value = true\n    }, [texture, gl])\n\n    useEffect(() => {\n      if (!material.current) return\n      material.current.uniforms.u_res.value.set(size.width, size.height)\n      material.current.uniforms.u_rect.value.set(scale?.[0], scale?.[1])\n    }, [size, scale])\n\n    useFrame((_, delta) => {\n      if (!scrollState.inViewport || !mesh.current || !material.current) return\n\n      if (!material.current.uniforms.u_loaded.value) return\n\n      material.current.uniforms.u_time.value += delta\n\n      // update scale while animating too\n      material.current.uniforms.u_rect.value.set(mesh.current.scale.x, mesh.current.scale.y)\n\n      // px velocity\n      material.current.uniforms.u_velocity.value = scroll.velocity\n\n      // percent of total visible distance that was scrolled (0 = just outside bottom of screen, 1 = just outside top of screen)\n      material.current.uniforms.u_progress.value = scrollState.progress\n\n      // percent of item height in view\n      material.current.uniforms.u_visibility.value = scrollState.visibility\n      // percent of window height scrolled since visible\n      material.current.uniforms.u_viewport.value = scrollState.viewport\n\n      if (invalidateFrameLoop) invalidate()\n    })\n\n    const args = useMemo(\n      () => [\n        {\n          vertexShader,\n          fragmentShader,\n        },\n      ],\n      [vertexShader, fragmentShader]\n    )\n\n    return (\n      <>\n        <mesh ref={mesh} {...props}>\n          <planeGeometry attach=\"geometry\" args={[1, 1, widthSegments, heightSegments]} />\n          <shaderMaterial\n            ref={material}\n            args={args as [ShaderMaterialParameters]}\n            transparent={true}\n            uniforms={uniforms}\n          />\n        </mesh>\n      </>\n    )\n  }\n)\n", "import React, { useRef } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { Mesh } from 'three'\n\nimport { ScrollScene, useScrollRig } from '@14islands/r3f-scroll-rig'\n\n// Parallax group inside ScrollScene\nconst ParallaxGroup = ({ children, scrollState, parallax }: any) => {\n  const mesh = useRef<Mesh>(null!)\n  const size = useThree((s) => s.size)\n  const { scaleMultiplier } = useScrollRig()\n\n  useFrame(() => {\n    if (!scrollState.inViewport) return\n    const parallaxProgress = scrollState.progress * 2 - 1\n    mesh.current.position.y = parallax * parallaxProgress * scaleMultiplier * size.height\n  })\n\n  return <mesh ref={mesh}>{children}</mesh>\n}\n\n/* Speed=1 is no parallax */\nexport const ParallaxScrollScene = ({ children, speed = 1, ...props }: any) => {\n  const extraMargin = 50 // add 50vh extra margin to avoid aggressive clipping\n  const parallaxAmount = speed - 1\n  return (\n    // @ts-ignore\n    <ScrollScene scissor={false} inViewportMargin={`${Math.max(0, 1 - 0.5) * 200 + extraMargin}%`} {...props}>\n      {(props) => (\n        <ParallaxGroup parallax={parallaxAmount} {...props}>\n          {children(props)}\n        </ParallaxGroup>\n      )}\n    </ScrollScene>\n  )\n}\n", "/**\n * An object for memoizing vecType functions.\n * @type {Object}\n * @private\n */\nlet vecTypes = (function () {\n  const handler = {\n    get: function (obj, prop) {\n      if (!obj.hasOwnProperty(prop)) {\n        obj[prop] = getVecType(prop)\n      }\n      return obj[prop]\n    }\n  }\n\n  return new Proxy({}, handler)\n})()\n\n/**\n * A class for fixed-size vectors of numbers.\n * @extends Array\n */\nclass vecn extends Array {\n  /**\n   * Creates a vecn of the specified dimension. This should never be called\n   * by the user (as if this were an abstract class).\n   * @param {number} dimension The dimension of this vector.\n   * @param {number[]} [args=[]] The numbers to be put in the vector.\n   */\n  constructor (dimension, args) {\n    args = flattenOuter(args)\n\n    if (!args.every((x) => type(x) === 'Number')) {\n      throw new TypeError('All arguments must be numbers.')\n    }\n    if (args.length > 1 && args.length !== dimension) {\n      throw new Error('Argument list must be empty, have a single number, or have a length equal to the dimension.')\n    }\n\n    if (args.length === 0) {\n      args = [0]\n    }\n    if (args.length === 1 && type(args[0]) === 'Number') {\n      args = Array(dimension).fill(args[0])\n    }\n\n    if (dimension > 1) {\n      super(...args)\n    } else {\n      super(1)\n      this[0] = args[0]\n    }\n\n    Reflect.defineProperty(this, 'pop', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'push', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'shift', {\n      value: undefined,\n      enumerable: false\n    })\n    Reflect.defineProperty(this, 'unshift', {\n      value: undefined,\n      enumerable: false\n    })\n  }\n\n  /**\n   * The L2 norm (Euclidian norm) of the vector.\n   * @type {number}\n   */\n  get magnitude () {\n    return this.pnorm(2)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Arithmetic\n\n  /**\n   * Returns a vector where this is divided by v componentwise. If v is\n   * a single number, the vector is scaled by 1/v.\n   * @param {number|number[]} v The value to multiply with.\n   *\n   * @returns {vecn} A new vector with the divided components.\n   */\n  div (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.length; ++i) {\n      result[i] = this[i] / v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where v is subtracted from the components of this\n   * vector. If v is a single number, it is subtracted to each component. If v\n   * is a vector, the vectors are combined componentwise.\n   * @param {number|number[]} v The value to subtract from this vector.\n   *\n   * @returns {vecn} A new vector with the combined components.\n   */\n  minus (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] - v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Negates each element in this vector.\n   * @returns {vecn} A new vector where all elements are negated.\n   */\n  neg () {\n    return vecTypes[this.dim](this.times(-1))\n  }\n\n  /**\n   * Returns a vector where v is added to the components of this vector. If v\n   * is a single number, it is added to each component. If v is a vector, the\n   * vectors are added componentwise.\n   * @param {number|number[]} v The value to add to this vector.\n   *\n   * @returns {vecn} A new vector with the summed components.\n   */\n  plus (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] + v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where each component of this was raised to a power p.\n   * @param {number} p The power to raise each component by.\n   *\n   * @returns {vecn} A new vector with the exponentiated components.\n   */\n  pow (p) {\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = Math.pow(this[i], p)\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  /**\n   * Returns a vector where v and this are multiplied componentwise. If v is\n   * a single number, the vector is scaled by v.\n   * @param {number|number[]} v The value to multiply with.\n   *\n   * @returns {vecn} A new vector with the multiplied components.\n   */\n  times (v) {\n    checkCompatibility(v, this.dim, true)\n    if (type(v) === 'Number') {\n      v = (new Array(this.dim)).fill(v)\n    }\n\n    let result = []\n    for (let i = 0; i < this.dim; ++i) {\n      result[i] = this[i] * v[i]\n    }\n    return vecTypes[this.dim](result)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Vector Operations\n\n  /**\n   * Dot product of two vectors.\n   * @param {number[]} v The vector to dot with this one.\n   *\n   * @returns {number} The dot product between this and v.\n   */\n  dot (v) {\n    checkCompatibility(v, this.dim)\n\n    let result = 0\n    for (let i = 0; i < this.dim; ++i) {\n      result += this[i] * v[i]\n    }\n    return result\n  }\n\n  /**\n   * Scales this vector to a magnitude of 1.\n   *\n   * @returns {vecn} A new vector with scaled components.\n   */\n  normalize () {\n    return this.div(this.magnitude)\n  }\n\n  /**\n   * Evaluates the p-norm (or lp-norm) of this vector.\n   * @param {number} p The p-value to evaluate.\n   *\n   * @returns {number} The norm of this vector.\n   */\n  pnorm (p) {\n    let result = 0\n    for (let i = 0; i < this.dim; ++i) {\n      result += Math.pow(Math.abs(this[i]), p)\n    }\n    return Math.pow(result, 1 / p)\n  }\n\n  /**\n   * Reflects this vector across the provided vector. The normal can be imagined\n   * as a surface normal or as describing a hyperpalane.\n   * @param {number[]} normal A vector describing the hyperplane to reflect off of.\n   *\n   * @returns {vecn} The reflected vector.\n   */\n  reflect (normal) {\n    const n = normal.normalize()\n    return this.minus(n.times(2 * this.dot(n)))\n  }\n\n  // --------------------------------------------------------------------------\n  //   Extras\n\n  /**\n   * Finds the indices of the max value in this vector.\n   *\n   * @returns {number[]} An array of indices corresponding to the max values.\n   */\n  argmax () {\n    const maxVal = this.max()\n    return this.reduce((acc, x, i) => x === maxVal ? acc.concat([i]) : acc, [])\n  }\n\n  /**\n   * Finds the indices of the min value in this vector.\n   *\n   * @returns {number[]} An array of indices corresponding to the min values.\n   */\n  argmin () {\n    const minVal = this.min()\n    return this.reduce((acc, x, i) => x === minVal ? acc.concat([i]) : acc, [])\n  }\n\n  /**\n   * Creates a new vector from the provided indices of this one. Basically\n   * equivalent to swizzling.\n   * @param {number[]} indices The indices to select into a new vector.\n   *\n   * @returns {vecn} A new vector from the provided indices.\n   */\n  choose (indices) {\n    if (!Array.isArray(indices)) {\n      throw new TypeError('Argument must be a list of indices.')\n    }\n    if (!indices.every((i) => i < this.dim && isIndex(i.toString()))) {\n      throw new RangeError('All elements of argument must be valid indices.')\n    }\n\n    let v = []\n    indices.forEach((i) => v.push(this[i]))\n    return vecTypes[v.length](v)\n  }\n\n  /**\n   * Creates a duplicate of this vector. Same as passing this vector through\n   * the factory that created it.\n   *\n   * @returns {vecn} A deep copy of this vector.\n   */\n  copy () {\n    return vecTypes[this.dim](this)\n  }\n\n  /**\n   * Returns whether every element in each vector is equal.\n   * @param {number[]} v A vector to test against.\n   *\n   * @returns {boolean} True if both vectors have the same dimension and values.\n   */\n  equals (v) {\n    return v.length === this.dim && v.every((x, i) => this[i] === x)\n  }\n\n  /**\n   * Returns whether every element in each vector is approximately equal.\n   * @param {number[]} v A vector to test against.\n   * @param {number} epsilon The largest meaningful difference between two values.\n   *\n   * @returns {boolean} True if both vectors have the same dimension and the\n   * distance between each number is less than epsilon.\n   */\n  approximatelyEquals (v, epsilon = 0.00000001) {\n    return v.length === this.dim && v.every((x, i) => Math.abs(this[i] - x) < epsilon)\n  }\n\n  /**\n   * Returns the max value of this vector.\n   *\n   * @returns {number} The max value of this vector.\n   */\n  max () {\n    return Math.max(...this)\n  }\n\n  /**\n   * Returns the min value of this vector.\n   *\n   * @returns {number} The min value of this vector.\n   */\n  min () {\n    return Math.min(...this)\n  }\n\n  /**\n   * Sums the components of this vector.\n   *\n   * @returns {number} The sum of the components of this vector.\n   */\n  sum () {\n    return this.reduce((acc, x) => acc + x, 0)\n  }\n\n  /**\n   * Converts this vector into an Array.\n   *\n   * @returns {number[]} An array of the contents of this vector.\n   */\n  toArray () {\n    return Array.from(this)\n  }\n\n  // --------------------------------------------------------------------------\n  //   Array Overrides\n\n  /**\n   * Same as Array.prototype.concat, but return value is of a new vecType.\n   *\n   * @returns {vecn}\n   */\n  concat (...args) {\n    const result = super.concat.apply(this.toArray(), args)\n    return vecTypes[result.length](result)\n  }\n\n  /**\n   * Same as Array.prototype.filter, but returns an Array if the result has 0\n   * entries.\n   *\n   * @returns {vecn|number[]}\n   */\n  filter (...args) {\n    const result = super.filter.apply(this.toArray(), args)\n    if (result.length > 0) {\n      return vecTypes[result.length](result)\n    }\n    return result\n  }\n\n  /**\n   * Same as Array.prototype.map, but returns an Array if the result contains\n   * non-numbers.\n   *\n   * @returns {vecn|Array}\n   */\n  map (...args) {\n    const result = super.map(...args)\n    if (result.every((x) => type(x) === 'Number')) {\n      return result\n    }\n    return result.toArray()\n  }\n\n  /**\n   * Same as Array.prototype.slice, but returns an Array if the result has 0\n   * entries.\n   */\n  slice (...args) {\n    const result = super.slice.apply(this.toArray(), args)\n    if (result.length > 0) {\n      return vecTypes[result.length](result)\n    }\n    return result\n  }\n\n  /**\n   * A restrictive version of the Array.prototype.splice that requires all\n   * removed elements to be replaced.\n   */\n  splice (...args) {\n    let test = this.toArray()\n    test.splice(...args)\n\n    if (test.length !== this.dim) {\n      throw new Error('All removed elements must be replaced.')\n    }\n    if (!test.every((x) => type(x) === 'Number')) {\n      throw new TypeError('All elements must be numbers.')\n    }\n\n    test.forEach((x, i) => { this[i] = x })\n  }\n\n  toString () {\n    return this.reduce((s, x, i) => {\n      return s + x + (i === this.dim - 1 ? ' ' : ', ')\n    }, '[ ') + ']'\n  }\n}\n\n// --------------------------------------------------------------------------\n//   General Tools\n\n/**\n * Adds an arbitrary number of vectors together. All vectors must be of the same\n * dimension.\n * @param {...vecn} vecs Vectors to add together.\n *\n * @returns {vecn} The sum of all the provided vectors.\n */\nfunction add (...vecs) {\n  const dim = vecs[0].dim\n  if (!vecs.every((v) => v.dim === dim)) {\n    throw new TypeError('All vectors must have the same dimension.')\n  }\n  return vecs.reduce((acc, v) => acc.plus(v), vecTypes[dim]())\n}\n\n/**\n * The validator to be used in the proxy for all vec objects. Catches swizzling\n * properties, makes sure assignment only works for indices, and disallows\n * non-numerical assignments. Used in getVecType.\n * @constant\n * @type {Object}\n * @private\n */\nconst validator = {\n  set: function (obj, prop, value) {\n    if (prop === 'length') {\n      return false\n    }\n    if (isIndex(prop)) {\n      if (Number(prop) >= obj.dim) {\n        throw new RangeError('Vector may not have more elements than dimension.')\n      } else if (type(value) !== 'Number') {\n        throw new TypeError('Vectors may only contain numbers.')\n      } else {\n        obj[prop] = value\n        return true\n      }\n    }\n\n    const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString())\n    if (obj.dim <= 4 && swizzleSymbolMap) {\n      swizzleSet(obj, prop.toString(), swizzleSymbolMap, value)\n      return true\n    }\n\n    return false\n  },\n  get: function (obj, prop) {\n    const swizzleSymbolMap = getSwizzleSymbolMap(prop.toString())\n    if (obj.dim <= 4 && swizzleSymbolMap) {\n      return swizzleGet(obj, prop, swizzleSymbolMap)\n    }\n\n    return obj[prop]\n  }\n}\n\n/**\n * Returns a factory function for vectors of the specified dimension.\n * @param {number} dim The dimension of the new vector type.\n *\n * @returns {Function} A factory (not a constructor) for creating new vecs.\n */\nfunction getVecType (dim) {\n  dim = Number(dim)\n\n  if (!(dim in vecTypes)) {\n    if (isNaN(dim)) throw new TypeError('Dimension must be coercible to a number.')\n    if (dim <= 0) throw new RangeError('Dimension must be positive.')\n    if (!Number.isInteger(dim)) throw new RangeError('Dimension must be positive.')\n\n    // Doing a little bit of exploiting ES6 to dynamically name the class\n    let classname = 'vec' + dim\n    let VecType = ({[classname]: class extends vecn {\n      constructor (...args) {\n        if (args.length === 1 && args[0] instanceof vecn) {\n          if (args[0].dim > dim) {\n            throw new TypeError('Cannot demote vectors.')\n          }\n          args = promoteArrayDimension(args[0].toArray(), dim)\n        }\n        super(dim, args)\n        Reflect.defineProperty(this, 'dim', {\n          value: dim,\n          writable: false,\n          enumerable: false\n        })\n      }\n    }})[classname]\n\n    let factory = function factory (...args) {\n      let target = new VecType(...args)\n      Object.preventExtensions(target)\n      return new Proxy(target, validator)\n    }\n    vecTypes[dim] = factory\n  }\n\n  return vecTypes[dim]\n}\n\n/**\n * The correct function for determining whether an object is a vecn.\n * @param {*} v The object in question.\n *\n * @returns {boolean} True if the object is an instance of vecn.\n */\nfunction isVec (v) {\n  return v instanceof vecn\n}\n\n/**\n * Linearly interpolates between two vectors.\n * @param {vecn} v1 The starting vector.\n * @param {vecn} v2 The ending vector.\n * @param {number} t The interpolant, which is clamped to the inteval [0, 1].\n *\n * @returns {vecn} The interpolated vector.\n */\nfunction lerp (v1, v2, t) {\n  if (v1.dim !== v2.dim) throw new TypeError('Vectors must have the same dimension.')\n  t = t < 0 ? 0 : (t > 1 ? 1 : t)\n  return v1.plus(v2.minus(v1).times(t))\n}\n\n/**\n * Multiplies an arbitrary number of vectors together. All vectors must be of the same\n * dimension.\n * @param {...vecn} vecs Vectors to multiply together.\n *\n * @returns {vecn} The product of all the provided vectors.\n */\nfunction multiply (...vecs) {\n  const dim = vecs[0].dim\n  if (!vecs.every((v) => v.dim === dim)) throw new TypeError('All vectors must have the same dimension.')\n  return vecs.reduce((acc, v) => acc.times(v), vecTypes[dim](1))\n}\n\n/**\n * Spherically interpolates between two vectors.\n * @param {vecn} v1 The starting vector.\n * @param {vecn} v2 The ending vector.\n * @param {number} t The interpolant, which is clamped to the inteval [0, 1].\n *\n * @returns {vecn} The interpolated vector.\n */\nfunction slerp (v1, v2, t) {\n  if (v1.dim !== v2.dim) throw new TypeError('Vectors must have the same dimension.')\n\n  t = t < 0 ? 0 : (t > 1 ? 1 : t)\n  let dot = v1.normalize().dot(v2.normalize())\n  dot = dot < -1 ? -1 : (dot > 1 ? 1 : dot)\n  const theta = Math.acos(dot) * t\n  const relative = v2.minus(v1.times(dot)).normalize()\n  const magnitude = v1.magnitude + ((v2.magnitude - v1.magnitude) * t)\n  return v1.times(Math.cos(theta)).plus(relative.times(Math.sin(theta)))\n    .normalize().times(magnitude)\n}\n\n// --------------------------------------------------------------------------\n//   Swizzling\n\n/**\n * The index corresponding to common names for indexing vectors.\n * @constant\n * @type {Object}\n * @private\n */\nconst namedIndices = [\n  {x: 0, y: 1, z: 2, w: 3},\n  {r: 0, g: 1, b: 2, a: 3},\n  {s: 0, t: 1, p: 2, q: 3}\n]\n\n/**\n * Gets the set of symbols corresponding to indices used for swizzling.\n * @private\n * @param {string} s The string used as a property to swizzle.\n *\n * @returns {Object} A map from characters to indices.\n */\nfunction getSwizzleSymbolMap (s) {\n  return namedIndices.find((map) => {\n    return s.split('').every((c) => c in map)\n  })\n}\n\n/**\n * Creates a new vector from the named indices given by swizzling.\n * @private\n * @param {vecn} v The vector to pull data from. The dimension is assumed to be\n * 2, 3, or 4, but this isn't enforced here.\n * @param {string} s The property being used to swizzle (e.g. 'xxy' or 'z').\n * @param {Object} set A map from characters to indices (assumed to be valid).\n *\n * @returns {undefined|number|vecn} Either undefined (if s isn't a valid swizzle\n * string), a number (if s has a length of 1), or a vecn where the values have\n * been rearranged according to the order given in s.\n */\nfunction swizzleGet (v, s, set) {\n  const newDim = s.length\n\n  if (newDim === 1) {\n    return v[set[s]]\n  }\n\n  let values = s.split('').reduce((acc, x) => {\n    let i = set[x]\n    return acc && i < v.dim ? acc.concat([v[i]]) : undefined\n  }, [])\n  return values ? new vecTypes[newDim](...values) : undefined\n}\n\n/**\n * Assigns the indexed values in v to the values in newVals in the order they\n * are described in in s.\n * @private\n * @param {vecn} v The starting vector.\n * @param {string} s The property being used to swizzle (e.g. 'xyz' or 'xz').\n * @param {Object} map A map from characters to indices (assumed to be valid).\n * @param {number|number[]} newVals The right hand side of the assignment\n *\n * @returns {vecn} A copy of v with the correct elements replaced.\n */\nfunction swizzleSet (v, s, map, newVals) {\n  if (s.length === 1) {\n    if (type(newVals) !== 'Number') {\n      throw new TypeError('Must set to a number')\n    }\n    v[map[s]] = newVals\n    return\n  }\n\n  if (!Array.isArray(newVals)) throw new TypeError('Right-hand side must be an array.')\n  if (s.length !== newVals.length) throw new TypeError('Right-hand side must have matching length.')\n  if (!newVals.every((item) => type(item) === 'Number')) throw new TypeError('All new values must be numbers.')\n\n  if (s.split('').some((c) => map[c] >= v.dim)) {\n    return\n  }\n\n  let valid = true\n  for (let i = 0, unique = {}; i < s.length; ++i) {\n    if (unique.hasOwnProperty(s[i])) {\n      valid = false\n      break\n    }\n    unique[s[i]] = true\n  }\n  if (!valid) throw new SyntaxError('Swizzle assignment does not allow symbols to be repeated.')\n\n  s.split('').map((c) => map[c]).forEach((index, i) => { v[index] = newVals[i] })\n}\n\n// --------------------------------------------------------------------------\n//   Helpers\n\n/**\n * Checks whether something is valid to do vector operations with and throws\n * a TypeError if not.\n * @private\n * @param {*} o An object to check.\n * @param {number} dim The dimension to check against.\n * @param {boolean} [numberValid=false] Whether scalars are compatible for the operation.\n */\nfunction checkCompatibility (o, dim, numberValid = false) {\n  if (numberValid && type(o) === 'Number') {\n    return\n  } else if (o.length && o.length === dim) {\n    return\n  }\n  throw new TypeError(`Invalid argument. Input must have matching dimension${numberValid ? 'or be a scalar' : ''}.`)\n}\n\n/**\n * Removes outer arrays and returns a reference to the innermost array. For\n * example, [[1, 2]] becomes [1, 2]. [[[['a'], true]]] becomes [['a'], true].\n * @private\n * @param {Array} arr The array to flatten.\n *\n * @returns {Array} A reference to the innermost array in arr.\n */\nfunction flattenOuter (arr) {\n  if (!(arr instanceof Array) || arr.length !== 1) {\n    return arr\n  }\n  if (arr[0] instanceof Array) {\n    return flattenOuter(arr[0])\n  }\n  return arr\n}\n\n/**\n * Checks whether a provided string can be used as a valid index into an array.\n * @private\n * @param {string} n A string representation of the number in question.\n *\n * @returns {boolean} True if n can be used to index an array.\n */\nfunction isIndex (n) {\n  return !isNaN(n) &&\n         Number(n).toString() === n &&\n         Number.isInteger(Number(n)) &&\n         Number(n) >= 0\n}\n\n/**\n * Lengthens an exsting array and fills new entries with 0 (does not mutate).\n * @private\n * @param {Array} arr The source array.\n * @param {number} dim The dimension of the new array.\n *\n * @returns {Array} A new array with length dim and arr as a prefix.\n */\nfunction promoteArrayDimension (arr, dim) {\n  return [...Array(dim)].map((_, i) => i < arr.length ? arr[i] : 0)\n}\n\n/**\n * Returns a string representing the type of an object. Similar to typeof, but\n * better with wrapped primitives, null, Array, etc...\n * @private\n * @param {*} obj The object to check the type of.\n *\n * @returns {string} A capitalized string describing the perceived type (i.e. 'Number', 'Array', etc...)\n */\nfunction type (obj) {\n  return Object.prototype.toString.call(obj).slice(8, -1)\n}\n\nmodule.exports = {\n  getVecType,\n  isVec,\n  vec2: vecTypes[2],\n  vec3: vecTypes[3],\n  vec4: vecTypes[4],\n\n  add,\n  multiply,\n  lerp,\n  slerp\n}\n", "import React, { useRef, useMemo } from 'react'\nimport { useFrame, useThree } from '@react-three/fiber'\nimport { Group } from 'three'\nimport vecn from 'vecn'\n// @ts-ignore\nimport lerp from '@14islands/lerp'\n\nimport { ScrollScene, useScrollRig } from '@14islands/r3f-scroll-rig'\n\n// Sticky mesh that covers full viewport size\nconst StickyChild = ({\n  children,\n  childTop,\n  childBottom,\n  scrollState,\n  parentScale,\n  childScale,\n  scaleMultiplier,\n  priority,\n  stickyLerp = 1.0,\n  offsetTop = 0,\n}: any) => {\n  const group = useRef<Group>(null!)\n  const size = useThree((s) => s.size)\n\n  useFrame((_, delta) => {\n    if (!scrollState.inViewport) return\n\n    const topOffset = (childTop - offsetTop) / size.height\n    const bottomOffset = (childBottom / parentScale[1]) * scaleMultiplier\n\n    //  move to top of sticky area\n    const yTop = parentScale[1] * 0.5 - childScale[1] * 0.5 - offsetTop * scaleMultiplier\n    const yBottom = -parentScale[1] * 0.5 + childScale[1] * 0.5\n    const ySticky =\n      -childTop * scaleMultiplier +\n      yTop -\n      (scrollState.viewport - 1) * size.height * scaleMultiplier +\n      offsetTop * scaleMultiplier\n\n    let y = group.current.position.y\n\n    // enter\n    if (scrollState.viewport + topOffset < 1) {\n      y = yTop\n    }\n    // sticky\n    else if (scrollState.visibility - bottomOffset < 1) {\n      y = ySticky\n    }\n    // exit\n    else {\n      y = yBottom\n    }\n\n    group.current.position.y = lerp(group.current.position.y, y, stickyLerp, delta)\n  }, priority) // must happen after ScrollScene's useFrame to be buttery\n\n  return <group ref={group}>{children}</group>\n}\n\nconst renderAsSticky = (\n  children: any,\n  size: any,\n  childStyle: any,\n  parentStyle: any,\n  scaleMultiplier: number,\n  { stickyLerp, fillViewport }: any\n) => {\n  return ({ scale, ...props }: any) => {\n    let childScale = vecn.vec3(parseFloat(childStyle.width), parseFloat(childStyle.height), 1)\n    let childTop = parseFloat(childStyle.top)\n    let childBottom = size.height - childTop - childScale[1]\n\n    if (fillViewport) {\n      childScale = vecn.vec3(size.width, size.height, 1)\n      childTop = 0\n      childBottom = 0\n    }\n\n    const offsetTop = parseFloat(parentStyle.top)\n\n    return (\n      // @ts-ignore\n      <StickyChild\n        offsetTop={offsetTop}\n        parentScale={scale}\n        childScale={childScale.times(scaleMultiplier)}\n        stickyLerp={stickyLerp}\n        childTop={childTop}\n        childBottom={childBottom}\n        scaleMultiplier={scaleMultiplier}\n        {...props}\n      >\n        {children({\n          scale: childScale.times(scaleMultiplier),\n          parentScale: scale,\n          ...props,\n        })}\n      </StickyChild>\n    )\n  }\n}\n\nexport const StickyScrollScene = ({ children, track, stickyLerp, fillViewport, ...props }: any) => {\n  const size = useThree((s) => s.size)\n  const { scaleMultiplier } = useScrollRig()\n\n  const internalRef = useRef(track.current)\n\n  // if tracked element is position:sticky, track the parent instead\n  // we want to track the progress of the entire sticky area\n  const [childStyle, parentStyle] = useMemo(() => {\n    const style = getComputedStyle(track.current)\n\n    let parentStyle\n    if (style.position === 'sticky') {\n      internalRef.current = track.current.parentElement\n\n      // make sure parent is relative/absolute so we get accurante offsetTop\n      parentStyle = getComputedStyle(internalRef.current)\n      if (parentStyle.position === 'static') {\n        console.error(\n          'StickyScrollScene: parent of position:sticky needs to be position:relative or position:absolute (currently set to position:static)'\n        )\n      }\n    } else {\n      console.error('StickyScrollScene: tracked element is not position:sticky')\n    }\n    return [style, parentStyle]\n  }, [track, size])\n\n  return (\n    <ScrollScene track={internalRef} {...props}>\n      {renderAsSticky(children, size, childStyle, parentStyle, scaleMultiplier, {\n        stickyLerp,\n        fillViewport,\n      })}\n    </ScrollScene>\n  )\n}\n", "const _lerp = require('lerp')\n\n/**\n * Drop-in replacement of standard lerp with optional frame delta and target fps\n * to maintain constant animation speed at various fps\n * \n * Based on http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n * \n * @param {number} source Current value\n * @param {number} target Value to lerp towards\n * @param {number} rate Interpolation rate\n * @param {number} frameDelta Optional frame delta time in seconds. Should be 1/60 for a steady 60fps.\n * @param {number} targetFps Optional, target is 60 by default\n * @returns {number} interpolated value\n */\n\nfunction lerp(source, target, rate, frameDelta, targetFps = 60){\n  \n  // return normal lerp if no delta was passed\n  if (typeof frameDelta === 'undefined') {\n    return _lerp(source, target, rate)\n  }\n\n  const relativeDelta = frameDelta / (1 / targetFps)\n  const smoothing = 1 - rate\n  return _lerp(source, target, 1 - Math.pow(smoothing, relativeDelta));\n}\n\nmodule.exports = lerp", "function lerp(v0, v1, t) {\n    return v0*(1-t)+v1*t\n}\nmodule.exports = lerp"],
  "mappings": "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",
  "names": ["WebGLText", "_ref", "el", "children", "material", "scale", "font", "fontOffsetY", "fontOffsetX", "overrideEmissive", "color", "props", "_objectWithoutPropertiesLoose", "_excluded", "size", "useThree", "scaleMultiplier", "useScrollRig", "textColor", "fontSize", "textAlign", "lineHeight", "letterSpacing", "useMemo", "current", "cs", "window", "getComputedStyle", "parentElement", "parseFloat", "useEffect", "emissive", "xOffset", "React", "createElement", "Text", "_extends", "maxWidth", "width", "overflowWrap", "anchorX", "anchorY", "position", "height", "WebGLImage", "forwardRef", "ref", "scrollState", "vertexShader", "fragmentShader", "invalidateFrameLoop", "widthSegments", "heightSegments", "useRef", "mesh", "useImperativeHandle", "invalidate", "gl", "pixelRatio", "s", "viewport", "dpr", "scroll", "useScrollbar", "texture", "useImageAsTexture", "uniforms", "u_color", "value", "Color", "u_time", "u_pixelRatio", "u_progress", "u_visibility", "u_viewport", "u_velocity", "u_res", "Vector2", "u_rect", "u_size", "u_texture", "u_loaded", "u_scaleMultiplier", "set", "image", "useFrame", "_", "delta", "inViewport", "x", "y", "velocity", "progress", "visibility", "args", "Fragment", "attach", "transparent", "ParallaxGroup", "parallax", "ParallaxScrollScene", "speed", "parallaxAmount", "ScrollScene", "scissor", "inViewportMargin", "Math", "max", "vecTypes", "Proxy", "get", "obj", "prop", "hasOwnProperty", "getVecType", "vecn", "Array", "constructor", "dimension", "flattenOuter", "every", "type", "TypeError", "length", "Error", "fill", "super", "this", "Reflect", "defineProperty", "enumerable", "magnitude", "pnorm", "div", "v", "checkCompatibility", "dim", "result", "i", "minus", "neg", "times", "plus", "pow", "p", "dot", "normalize", "abs", "reflect", "normal", "n", "argmax", "maxVal", "reduce", "acc", "concat", "argmin", "minVal", "min", "choose", "indices", "isArray", "isIndex", "toString", "RangeError", "forEach", "push", "copy", "equals", "approximatelyEquals", "epsilon", "sum", "toArray", "from", "apply", "filter", "map", "slice", "splice", "test", "validator", "Number", "swizzleSymbolMap", "getSwizzleSymbolMap", "newVals", "item", "split", "some", "c", "valid", "unique", "SyntaxError", "index", "newDim", "values", "undefined", "isNaN", "isInteger", "classname", "VecType", "arr", "writable", "target", "Object", "preventExtensions", "namedIndices", "z", "w", "r", "g", "b", "a", "t", "q", "find", "o", "numberValid", "prototype", "call", "src", "isVec", "vec2", "vec3", "vec4", "add", "vecs", "multiply", "lerp", "v1", "v2", "slerp", "theta", "acos", "relative", "cos", "sin", "_excluded2", "StickyChild", "childTop", "childBottom", "parentScale", "childScale", "priority", "stickyLerp", "offsetTop", "group", "yTop", "source", "rate", "frameDelta", "targetFps", "StickyScrollScene", "_ref2", "track", "fillViewport", "internalRef", "childStyle", "parentStyle", "style", "console", "error", "renderAsSticky", "top"]
}
