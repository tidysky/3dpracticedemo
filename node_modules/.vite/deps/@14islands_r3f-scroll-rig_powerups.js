import {
  Text
} from "./chunk-JBJGU4VA.js";
import "./chunk-BN5RQWWK.js";
import "./chunk-CMJTB2EU.js";
import "./chunk-NXESFFTV.js";
import "./chunk-OVIARIHN.js";
import "./chunk-OD2WYOIH.js";
import {
  Me,
  be,
  re,
  ve
} from "./chunk-OIRLFBLV.js";
import {
  useFrame,
  useThree
} from "./chunk-XU5R6TQV.js";
import "./chunk-UYWRPOP3.js";
import {
  Color,
  Vector2
} from "./chunk-RI5FDDU7.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@14islands/r3f-scroll-rig/dist/powerups.modern.js
var import_react = __toESM(require_react());
function d() {
  return d = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var i2 in r2) Object.prototype.hasOwnProperty.call(r2, i2) && (e2[i2] = r2[i2]);
    }
    return e2;
  }, d.apply(this, arguments);
}
function g(e2, t2) {
  if (null == e2) return {};
  var r2, i2, n2 = {}, o2 = Object.keys(e2);
  for (i2 = 0; i2 < o2.length; i2++) t2.indexOf(r2 = o2[i2]) >= 0 || (n2[r2] = e2[r2]);
  return n2;
}
var v = ["el", "children", "material", "scale", "font", "fontOffsetY", "fontOffsetX", "overrideEmissive", "color"];
var y = (i2) => {
  let { el: n2, children: o2, material: l, scale: c, font: m, fontOffsetY: h = 0, fontOffsetX: p = 0, overrideEmissive: f = false, color: y2 } = i2, w2 = g(i2, v);
  const { size: b2 } = useThree(), { scaleMultiplier: S2 } = re(), { textColor: E2, fontSize: A2, textAlign: x2, lineHeight: _2, letterSpacing: N2 } = (0, import_react.useMemo)(() => {
    if (!n2.current) return {};
    const e2 = window.getComputedStyle(n2.current);
    let t2 = y2 || e2.color;
    return !y2 && "rgba(0, 0, 0, 0)" === e2.color && n2.current.parentElement && (t2 = window.getComputedStyle(n2.current.parentElement).color), { letterSpacing: (parseFloat(e2.letterSpacing) || 0) / parseFloat(e2.fontSize), lineHeight: (parseFloat(e2.lineHeight) || 0) / parseFloat(e2.fontSize), textColor: t2, fontSize: parseFloat(e2.fontSize) * S2, textAlign: e2.textAlign };
  }, [n2, b2, c, y2, S2]);
  (0, import_react.useEffect)(() => {
    l && f && (l.emissive = y2);
  }, [l, y2, f]);
  let z2 = 0;
  return "left" === x2 || "start" === x2 ? z2 = -0.5 * c[0] : "right" !== x2 && "end" !== x2 || (z2 = 0.5 * c[0]), import_react.default.createElement(Text, d({ fontSize: A2, maxWidth: c ? c[0] : b2.width, lineHeight: _2, textAlign: x2, letterSpacing: N2, overflowWrap: "break-word", font: m, color: E2, anchorX: x2, anchorY: "top", position: [z2 + A2 * p, (c ? 0.5 * c[1] : 0.5 * b2.height) + A2 * h, 0], material: l }, w2), o2);
};
var w = ["el", "scale", "scrollState", "vertexShader", "fragmentShader", "invalidateFrameLoop", "widthSegments", "heightSegments"];
var b = (0, import_react.forwardRef)((i2, a) => {
  let { el: h, scale: v2, scrollState: y2, vertexShader: b2, fragmentShader: S2, invalidateFrameLoop: E2 = false, widthSegments: A2 = 128, heightSegments: x2 = 128 } = i2, _2 = g(i2, w);
  const N2 = (0, import_react.useRef)(null), z2 = (0, import_react.useRef)(null);
  (0, import_react.useImperativeHandle)(a, () => z2.current);
  const { invalidate: M2, gl: T2, size: k2 } = useThree(), O2 = useThree((e2) => e2.viewport.dpr), { scroll: V2 } = ve(), { scaleMultiplier: F2 } = re(), R2 = Me(h), P2 = (0, import_react.useMemo)(() => ({ u_color: { value: new Color("black") }, u_time: { value: 0 }, u_pixelRatio: { value: O2 }, u_progress: { value: 0 }, u_visibility: { value: 0 }, u_viewport: { value: 0 }, u_velocity: { value: 0 }, u_res: { value: new Vector2() }, u_rect: { value: new Vector2() }, u_size: { value: new Vector2() }, u_texture: { value: null }, u_loaded: { value: false }, u_scaleMultiplier: { value: F2 } }), [O2]);
  (0, import_react.useEffect)(() => {
    R2 && N2.current && (N2.current.uniforms.u_texture.value = R2, N2.current.uniforms.u_size.value.set(R2.image.width, R2.image.height), N2.current.uniforms.u_loaded.value = true);
  }, [R2, T2]), (0, import_react.useEffect)(() => {
    N2.current && (N2.current.uniforms.u_res.value.set(k2.width, k2.height), N2.current.uniforms.u_rect.value.set(null == v2 ? void 0 : v2[0], null == v2 ? void 0 : v2[1]));
  }, [k2, v2]), useFrame((e2, t2) => {
    y2.inViewport && z2.current && N2.current && N2.current.uniforms.u_loaded.value && (N2.current.uniforms.u_time.value += t2, N2.current.uniforms.u_rect.value.set(z2.current.scale.x, z2.current.scale.y), N2.current.uniforms.u_velocity.value = V2.velocity, N2.current.uniforms.u_progress.value = y2.progress, N2.current.uniforms.u_visibility.value = y2.visibility, N2.current.uniforms.u_viewport.value = y2.viewport, E2 && M2());
  });
  const L2 = (0, import_react.useMemo)(() => [{ vertexShader: b2, fragmentShader: S2 }], [b2, S2]);
  return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("mesh", d({ ref: z2 }, _2), import_react.default.createElement("planeGeometry", { attach: "geometry", args: [1, 1, A2, x2] }), import_react.default.createElement("shaderMaterial", { ref: N2, args: L2, transparent: true, uniforms: P2 })));
});
var S = ["children", "speed"];
var E = ({ children: t2, scrollState: r2, parallax: i2 }) => {
  const o2 = (0, import_react.useRef)(null), a = useThree((e2) => e2.size), { scaleMultiplier: c } = re();
  return useFrame(() => {
    r2.inViewport && (o2.current.position.y = i2 * (2 * r2.progress - 1) * c * a.height);
  }), import_react.default.createElement("mesh", { ref: o2 }, t2);
};
var A = (t2) => {
  let { children: r2, speed: i2 = 1 } = t2, n2 = g(t2, S);
  const o2 = i2 - 1;
  return import_react.default.createElement(be, d({ scissor: false, inViewportMargin: 200 * Math.max(0, 0.5) + 50 + "%" }, n2), (t3) => import_react.default.createElement(E, d({ parallax: o2 }, t3), r2(t3)));
};
var x = new Proxy({}, { get: function(e2, t2) {
  return e2.hasOwnProperty(t2) || (e2[t2] = z(t2)), e2[t2];
} });
var _ = class extends Array {
  constructor(e2, t2) {
    if (!(t2 = O(t2)).every((e3) => "Number" === F(e3))) throw new TypeError("All arguments must be numbers.");
    if (t2.length > 1 && t2.length !== e2) throw new Error("Argument list must be empty, have a single number, or have a length equal to the dimension.");
    0 === t2.length && (t2 = [0]), 1 === t2.length && "Number" === F(t2[0]) && (t2 = Array(e2).fill(t2[0])), e2 > 1 ? super(...t2) : (super(1), this[0] = t2[0]), Reflect.defineProperty(this, "pop", { value: void 0, enumerable: false }), Reflect.defineProperty(this, "push", { value: void 0, enumerable: false }), Reflect.defineProperty(this, "shift", { value: void 0, enumerable: false }), Reflect.defineProperty(this, "unshift", { value: void 0, enumerable: false });
  }
  get magnitude() {
    return this.pnorm(2);
  }
  div(e2) {
    k(e2, this.dim, true), "Number" === F(e2) && (e2 = new Array(this.dim).fill(e2));
    let t2 = [];
    for (let r2 = 0; r2 < this.length; ++r2) t2[r2] = this[r2] / e2[r2];
    return x[this.dim](t2);
  }
  minus(e2) {
    k(e2, this.dim, true), "Number" === F(e2) && (e2 = new Array(this.dim).fill(e2));
    let t2 = [];
    for (let r2 = 0; r2 < this.dim; ++r2) t2[r2] = this[r2] - e2[r2];
    return x[this.dim](t2);
  }
  neg() {
    return x[this.dim](this.times(-1));
  }
  plus(e2) {
    k(e2, this.dim, true), "Number" === F(e2) && (e2 = new Array(this.dim).fill(e2));
    let t2 = [];
    for (let r2 = 0; r2 < this.dim; ++r2) t2[r2] = this[r2] + e2[r2];
    return x[this.dim](t2);
  }
  pow(e2) {
    let t2 = [];
    for (let r2 = 0; r2 < this.dim; ++r2) t2[r2] = Math.pow(this[r2], e2);
    return x[this.dim](t2);
  }
  times(e2) {
    k(e2, this.dim, true), "Number" === F(e2) && (e2 = new Array(this.dim).fill(e2));
    let t2 = [];
    for (let r2 = 0; r2 < this.dim; ++r2) t2[r2] = this[r2] * e2[r2];
    return x[this.dim](t2);
  }
  dot(e2) {
    k(e2, this.dim);
    let t2 = 0;
    for (let r2 = 0; r2 < this.dim; ++r2) t2 += this[r2] * e2[r2];
    return t2;
  }
  normalize() {
    return this.div(this.magnitude);
  }
  pnorm(e2) {
    let t2 = 0;
    for (let r2 = 0; r2 < this.dim; ++r2) t2 += Math.pow(Math.abs(this[r2]), e2);
    return Math.pow(t2, 1 / e2);
  }
  reflect(e2) {
    const t2 = e2.normalize();
    return this.minus(t2.times(2 * this.dot(t2)));
  }
  argmax() {
    const e2 = this.max();
    return this.reduce((t2, r2, i2) => r2 === e2 ? t2.concat([i2]) : t2, []);
  }
  argmin() {
    const e2 = this.min();
    return this.reduce((t2, r2, i2) => r2 === e2 ? t2.concat([i2]) : t2, []);
  }
  choose(e2) {
    if (!Array.isArray(e2)) throw new TypeError("Argument must be a list of indices.");
    if (!e2.every((e3) => e3 < this.dim && V(e3.toString()))) throw new RangeError("All elements of argument must be valid indices.");
    let t2 = [];
    return e2.forEach((e3) => t2.push(this[e3])), x[t2.length](t2);
  }
  copy() {
    return x[this.dim](this);
  }
  equals(e2) {
    return e2.length === this.dim && e2.every((e3, t2) => this[t2] === e3);
  }
  approximatelyEquals(e2, t2 = 1e-8) {
    return e2.length === this.dim && e2.every((e3, r2) => Math.abs(this[r2] - e3) < t2);
  }
  max() {
    return Math.max(...this);
  }
  min() {
    return Math.min(...this);
  }
  sum() {
    return this.reduce((e2, t2) => e2 + t2, 0);
  }
  toArray() {
    return Array.from(this);
  }
  concat(...e2) {
    const t2 = super.concat.apply(this.toArray(), e2);
    return x[t2.length](t2);
  }
  filter(...e2) {
    const t2 = super.filter.apply(this.toArray(), e2);
    return t2.length > 0 ? x[t2.length](t2) : t2;
  }
  map(...e2) {
    const t2 = super.map(...e2);
    return t2.every((e3) => "Number" === F(e3)) ? t2 : t2.toArray();
  }
  slice(...e2) {
    const t2 = super.slice.apply(this.toArray(), e2);
    return t2.length > 0 ? x[t2.length](t2) : t2;
  }
  splice(...e2) {
    let t2 = this.toArray();
    if (t2.splice(...e2), t2.length !== this.dim) throw new Error("All removed elements must be replaced.");
    if (!t2.every((e3) => "Number" === F(e3))) throw new TypeError("All elements must be numbers.");
    t2.forEach((e3, t3) => {
      this[t3] = e3;
    });
  }
  toString() {
    return this.reduce((e2, t2, r2) => e2 + t2 + (r2 === this.dim - 1 ? " " : ", "), "[ ") + "]";
  }
};
var N = { set: function(e2, t2, r2) {
  if ("length" === t2) return false;
  if (V(t2)) {
    if (Number(t2) >= e2.dim) throw new RangeError("Vector may not have more elements than dimension.");
    if ("Number" !== F(r2)) throw new TypeError("Vectors may only contain numbers.");
    return e2[t2] = r2, true;
  }
  const i2 = T(t2.toString());
  return !!(e2.dim <= 4 && i2) && (function(e3, t3, r3, i3) {
    if (1 === t3.length) {
      if ("Number" !== F(i3)) throw new TypeError("Must set to a number");
      return void (e3[r3[t3]] = i3);
    }
    if (!Array.isArray(i3)) throw new TypeError("Right-hand side must be an array.");
    if (t3.length !== i3.length) throw new TypeError("Right-hand side must have matching length.");
    if (!i3.every((e4) => "Number" === F(e4))) throw new TypeError("All new values must be numbers.");
    if (t3.split("").some((t4) => r3[t4] >= e3.dim)) return;
    let n2 = true;
    for (let e4 = 0, r4 = {}; e4 < t3.length; ++e4) {
      if (r4.hasOwnProperty(t3[e4])) {
        n2 = false;
        break;
      }
      r4[t3[e4]] = true;
    }
    if (!n2) throw new SyntaxError("Swizzle assignment does not allow symbols to be repeated.");
    t3.split("").map((e4) => r3[e4]).forEach((t4, r4) => {
      e3[t4] = i3[r4];
    });
  }(e2, t2.toString(), i2, r2), true);
}, get: function(e2, t2) {
  const r2 = T(t2.toString());
  return e2.dim <= 4 && r2 ? function(e3, t3, r3) {
    const i2 = t3.length;
    if (1 === i2) return e3[r3[t3]];
    let n2 = t3.split("").reduce((t4, i3) => {
      let n3 = r3[i3];
      return t4 && n3 < e3.dim ? t4.concat([e3[n3]]) : void 0;
    }, []);
    return n2 ? new x[i2](...n2) : void 0;
  }(e2, t2, r2) : e2[t2];
} };
function z(e2) {
  if (!((e2 = Number(e2)) in x)) {
    if (isNaN(e2)) throw new TypeError("Dimension must be coercible to a number.");
    if (e2 <= 0) throw new RangeError("Dimension must be positive.");
    if (!Number.isInteger(e2)) throw new RangeError("Dimension must be positive.");
    let t2 = "vec" + e2, r2 = { [t2]: class extends _ {
      constructor(...t3) {
        if (1 === t3.length && t3[0] instanceof _) {
          if (t3[0].dim > e2) throw new TypeError("Cannot demote vectors.");
          t3 = function(e3, t4) {
            return [...Array(t4)].map((t5, r3) => r3 < e3.length ? e3[r3] : 0);
          }(t3[0].toArray(), e2);
        }
        super(e2, t3), Reflect.defineProperty(this, "dim", { value: e2, writable: false, enumerable: false });
      }
    } }[t2];
    x[e2] = function(...e3) {
      let t3 = new r2(...e3);
      return Object.preventExtensions(t3), new Proxy(t3, N);
    };
  }
  return x[e2];
}
var M = [{ x: 0, y: 1, z: 2, w: 3 }, { r: 0, g: 1, b: 2, a: 3 }, { s: 0, t: 1, p: 2, q: 3 }];
function T(e2) {
  return M.find((t2) => e2.split("").every((e3) => e3 in t2));
}
function k(e2, t2, r2 = false) {
  if (!(r2 && "Number" === F(e2) || e2.length && e2.length === t2)) throw new TypeError(`Invalid argument. Input must have matching dimension${r2 ? "or be a scalar" : ""}.`);
}
function O(e2) {
  return e2 instanceof Array && 1 === e2.length && e2[0] instanceof Array ? O(e2[0]) : e2;
}
function V(e2) {
  return !isNaN(e2) && Number(e2).toString() === e2 && Number.isInteger(Number(e2)) && Number(e2) >= 0;
}
function F(e2) {
  return Object.prototype.toString.call(e2).slice(8, -1);
}
var R = { getVecType: z, isVec: function(e2) {
  return e2 instanceof _;
}, vec2: x[2], vec3: x[3], vec4: x[4], add: function(...e2) {
  const t2 = e2[0].dim;
  if (!e2.every((e3) => e3.dim === t2)) throw new TypeError("All vectors must have the same dimension.");
  return e2.reduce((e3, t3) => e3.plus(t3), x[t2]());
}, multiply: function(...e2) {
  const t2 = e2[0].dim;
  if (!e2.every((e3) => e3.dim === t2)) throw new TypeError("All vectors must have the same dimension.");
  return e2.reduce((e3, t3) => e3.times(t3), x[t2](1));
}, lerp: function(e2, t2, r2) {
  if (e2.dim !== t2.dim) throw new TypeError("Vectors must have the same dimension.");
  return r2 = r2 < 0 ? 0 : r2 > 1 ? 1 : r2, e2.plus(t2.minus(e2).times(r2));
}, slerp: function(e2, t2, r2) {
  if (e2.dim !== t2.dim) throw new TypeError("Vectors must have the same dimension.");
  r2 = r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
  let i2 = e2.normalize().dot(t2.normalize());
  i2 = i2 < -1 ? -1 : i2 > 1 ? 1 : i2;
  const n2 = Math.acos(i2) * r2, o2 = t2.minus(e2.times(i2)).normalize(), s = e2.magnitude + (t2.magnitude - e2.magnitude) * r2;
  return e2.times(Math.cos(n2)).plus(o2.times(Math.sin(n2))).normalize().times(s);
} };
var P = ["scale"];
var L = ["children", "track", "stickyLerp", "fillViewport"];
var C = ({ children: t2, childTop: r2, childBottom: i2, scrollState: o2, parentScale: a, childScale: u, scaleMultiplier: c, priority: m, stickyLerp: h = 1, offsetTop: p = 0 }) => {
  const f = (0, import_react.useRef)(null), d2 = useThree((e2) => e2.size);
  return useFrame((e2, t3) => {
    if (!o2.inViewport) return;
    const n2 = 0.5 * a[1] - 0.5 * u[1] - p * c;
    let s = f.current.position.y;
    s = o2.viewport + (r2 - p) / d2.height < 1 ? n2 : o2.visibility - i2 / a[1] * c < 1 ? -r2 * c + n2 - (o2.viewport - 1) * d2.height * c + p * c : 0.5 * -a[1] + 0.5 * u[1], f.current.position.y = function(e3, t4, r3, i3, n3 = 60) {
      return o3 = t4, e3 * (1 - (s2 = void 0 === i3 ? r3 : 1 - Math.pow(1 - r3, i3 / (1 / n3)))) + o3 * s2;
      var o3, s2;
    }(f.current.position.y, s, h, t3);
  }, m), import_react.default.createElement("group", { ref: f }, t2);
};
var j = (r2) => {
  let { children: i2, track: o2, stickyLerp: l, fillViewport: a } = r2, c = g(r2, L);
  const m = useThree((e2) => e2.size), { scaleMultiplier: p } = re(), f = (0, import_react.useRef)(o2.current), [v2, y2] = (0, import_react.useMemo)(() => {
    const e2 = getComputedStyle(o2.current);
    let t2;
    return "sticky" === e2.position ? (f.current = o2.current.parentElement, t2 = getComputedStyle(f.current), "static" === t2.position && console.error("StickyScrollScene: parent of position:sticky needs to be position:relative or position:absolute (currently set to position:static)")) : console.error("StickyScrollScene: tracked element is not position:sticky"), [e2, t2];
  }, [o2, m]);
  return import_react.default.createElement(be, d({ track: f }, c), ((t2, r3, i3, n2, o3, { stickyLerp: s, fillViewport: l2 }) => (a2) => {
    let { scale: u } = a2, c2 = g(a2, P), m2 = R.vec3(parseFloat(i3.width), parseFloat(i3.height), 1), h = parseFloat(i3.top), p2 = r3.height - h - m2[1];
    l2 && (m2 = R.vec3(r3.width, r3.height, 1), h = 0, p2 = 0);
    const f2 = parseFloat(n2.top);
    return import_react.default.createElement(C, d({ offsetTop: f2, parentScale: u, childScale: m2.times(o3), stickyLerp: s, childTop: h, childBottom: p2, scaleMultiplier: o3 }, c2), t2(d({ scale: m2.times(o3), parentScale: u }, c2)));
  })(i2, m, v2, y2, p, { stickyLerp: l, fillViewport: a }));
};
export {
  A as ParallaxScrollScene,
  j as StickyScrollScene,
  b as WebGLImage,
  y as WebGLText
};
//# sourceMappingURL=@14islands_r3f-scroll-rig_powerups.js.map
